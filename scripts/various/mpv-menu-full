#!/bin/bash

##    Author: Barret E (2021-24) <archus@protonmail.com>
##    This file is the standalone version of mpv-playlists-manager.
##    https://github.com/archusXIV/mpv-playlists-manager/blob/main
##    Dependencies: ffmpeg, jq, mpv, yt-dlp.
##    Optionals: fzf, parallel, ueberzug, ranger, w3m, wmctrl, ytfzf.
##    Get the configurations files:
##    https://github.com/archusXIV/dotfiles/tree/main/mpm
##
##    Youtube-dl is for now kind of unmaintained so install and make a symlink with
##    https://github.com/yt-dlp/yt-dlp/releases
##    sudo pacman -S yt-dlp && yay -S youtube-dl
##    ln -s /usr/bin/yt-dlp ~/.local/bin/youtube-dl (if ~/.local/bin is in your $PATH)
##
##    This script rips video urls from Youtube and so on.
##    In our case we use ".m3u" files to store urls in and then be able
##    to watch from the site itself or download videos or just the audio.
##    We can save, remove or edit playlists & mpm config file (mpmrc).
##    https://github.com/archusXIV/dotfiles/tree/main/mpm
##    It is recommanded to disable mpv cache for better results on direct streaming,
##    or find a better cache parameter.

# shellcheck disable=SC1083,SC1091,SC2013,SC2015,SC2030,SC2031,SC2034,SC2044,SC2048,SC2076
# shellcheck disable=SC2086,SC2119,SC2120,SC2143,SC2153,SC2154,SC2164,SC2184,SC2207,SC2317
# shellcheck source=/dev/null

## but let's ensure temporary files are removed before we exit out.
trap _CleanTmpDir SIGTERM EXIT

VERSION="v.1.6-6"

: "${XDG_CONFIG_HOME:-$HOME/.config}"
CONF_DIR="$XDG_CONFIG_HOME/mpm"
MPMRC="$CONF_DIR/mpmrc"
THEMERC="$CONF_DIR/themerc"

[[ ! -d $CONF_DIR ]] && {
    mkdir -p "$CONF_DIR"
    cp /usr/local/share/doc/mpm/{mpmrc,themerc} "$CONF_DIR"
}
## summon our personal settings
. "$MPMRC"; . "$THEMERC"

[[ -n $playlists_dir ]] && \
cp -f "$SCRIPTDIR"/mpv-playlists-manager/mpm_yt-videos.m3u "$playlists_dir"

## prompts blinking & stop blinking
b=$'\e[5m';
nb=$'\e[25m';

supportedSites="https://github.com/ytdl-org/youtube-dl/blob/master/docs/supportedsites.md"
QUEUE="$playlists_dir/default.m3u"

# !!!!!!!!!!!!!!!! creates a blank line !!!!!!!!!!!!!!!!!!!
# so do not delete these characters "__" in the code below.
__() { printf '\n'; }

_GetLinesList() {
    case "$1" in
        -a) FILE="$AUDIO_URLS" ;;
        -l) FILE="$playlists_dir"/"$list" ;;
        -q) FILE="$QUEUE" ;;
        -v) FILE="$VIDEO_URLS" ;;
    esac
    [[ -s $FILE ]] && grep -c '^https' "$FILE"
}

_StartUp() {
    # needed to warn the user when the default list isn' t empty.
    [[ -s $DEFAULTM3UTITLES && -s $QUEUE ]] && {
        touch "$tmp_dir"/1
        cp -f "$DEFAULTM3UTITLES" "$DEFAULTITLES"
        rm "$DEFAULTM3UTITLES"
    }

    ! pgrep -x mpv >/dev/null && \
    rm "$NOWPLAYING" "$tmp_dir"/temporary* 2>/dev/null

    _Theme "$THEME"
}

_CheckDependencies() {
    ## Checking dependencies: softwares, directories and files.
    declare -a DEPS=( "ffmpeg" "jq" "mpv" "youtube-dl" "yt-dlp" \
                    "fzf" "parallel" "ueberzug" "wmctrl" "w3m" )

    for dep in "${DEPS[@]:0:5}"; do
        [[ -z $(command -v "$dep") ]] && {
            printf '%s\n' " $dep isn 't installed,...exiting!"
            notify-send -t 0 -u critical "$dep isn 't installed,...exiting!"
            exit 127
        }
    done

    for optional in "${DEPS[@]:5:10}"; do
        [[ -z $(command -v "$optional") ]] && {
            printf '%s\n' " For better experience consider installing $optional."
            sleep 4
        }
    done
    
    # MPMEDITOR & FILEMANAGER must be defined in ~/.config/mpm/mpmrc
    [[ -z $MPMEDITOR ]] && {
        printf '%s\n' " The config EDITOR is not set...exiting!"
        notify-send -t 0 -u critical "The config EDITOR is not set...exiting!"
        exit 1
    }

    command -v "$FILEMANAGER" >/dev/null || {
        printf '%s\n' " No terminal file manager found."
        notify-send -t 0 -u critical "No terminal file manager found."
        sleep 3
    }

    [[ -z $main_dir ]] && {
        printf '%s\n' " Variable main_dir in mpmrc is not defined...exiting!!!"
        exit 1
    }
    
    if [[ ! -d $main_dir ]]; then
        mkdir --parents \
        {"$audios_dir","$playlists_dir","$titles_dir","$tmp_dir","$videos_dir"}
    else
        [[ ! -d $audios_dir ]] && mkdir --parents "$audios_dir"
        [[ ! -d $playlists_dir ]] && mkdir --parents "$playlists_dir"
        [[ ! -d $titles_dir ]] && mkdir --parents "$titles_dir"
        [[ ! -d $tmp_dir ]] && mkdir --parents "$tmp_dir"
        [[ ! -d $videos_dir ]] && mkdir --parents "$videos_dir"
    fi

    [[ ! -f $QUEUE ]] && echo "#EXTM3U" > "$QUEUE"

    _StartUp && _Menu
}

# stolen from budRich <https://github.com/budRich>
_Prompt() {
    local screenprompt key default opts status

    default=y
    opts=yn

    [[ $1 =~ -([${opts}]) ]] \
        && default="${BASH_REMATCH[1]}" && shift

    screenprompt="$* [${default^^}/${opts/$default/}]:"

    # let's determine if we are in a terminal
    if [[ -t 2 ]]; then
        >&2 echo "$screenprompt"

        while :; do
            read -rsn 1

            key="${REPLY:-$default}"
            [[ $key =~ [${opts}] ]] || continue
            break
        done
    else
        key="$default"
    fi

    [[ ${key,,} = n ]] && status=1

    return "${status:-0}"
}

AUDIO_URLS="$tmp_dir/temporaryAudioUrls.m3u"
AUDIO_TITLES="$tmp_dir/temporaryAudioTitles"
VIDEO_URLS="$tmp_dir/temporaryVideoUrls.m3u"
VIDEO_TITLES="$tmp_dir/temporaryVideoTitles"

_SaveOnExit() {

    _Prompt -n \
        " ${critical}Some temporary lists aren't saved, quit anyway?: ${nc}" && {
        clear
        nc=$'\e[0m';
        SKULL=(
            "███████████████████████████" \
            "███████▀▀▀░░░░░░░▀▀▀███████" \
            "████▀░░░░░░░░░░░░░░░░░▀████" \
            "███│░░░░░░░░░░░░░░░░░░░│███" \
            "███│░░░░░░░░░░░░░░░░░░░│███" \
            "██▌│░░░░░░░░░░░░░░░░░░░│▐██" \
            "██░└┐░░░░░░░░░░░░░░░░░┌┘░██" \
            "██░░└┐░░░░░░░░░░░░░░░┌┘░░██" \
            "██░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░██" \
            "██▌░│███ ██▌░░░▐██ ███│░▐██" \
            "██▌░│██████▌░░░▐██████│░▐██" \
            "███░│▐███▀▀░░▄░░▀▀███▌│░███" \
            "██▀─┘░░░░░░░▐█▌░░░░░░░└─▀██" \
            "██▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄██" \
            "████▄─┘██▌░░░░░░░▐██└─▄████" \
            "█████░░▐█─┬┬┬┬┬┬┬─█▌░░█████" \
            "█████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████" \
            "███████▄░░░░░░░░░░░▄███████" \
            "██████████▄▄▄▄▄▄▄██████████" \
        )
        for skullPart in "${SKULL[@]}"; do
            echo -e "$skullPart"
            sleep 0.05
        done

        printf '%s\n' " ${critical}TOO BAD...BYE${nc}"
        exit
    }
    
    cd "$playlists_dir" || exit 1

    saveOnExitPrompt=( "[B]ack to menu" "Save [A]udio list" "Save [V]ideo list" )

    if [[ -s $AUDIO_URLS && -s $VIDEO_URLS ]]; then
        __
        echo -e " ${info}${saveOnExitPrompt[*]}${nc}"
    elif [[ -s $AUDIO_URLS && ! -f $VIDEO_URLS ]]; then
        unset saveOnExitPrompt[2]
        __
        echo -e " ${info}${saveOnExitPrompt[*]}${nc}"
    elif [[ -s $VIDEO_URLS && ! -f $AUDIO_URLS ]]; then
        unset saveOnExitPrompt[1]
        __
        echo -e " ${info}${saveOnExitPrompt[*]}${nc}"
    fi

    read -rsn 1 saveOnExitOptions
    case "$saveOnExitOptions" in
        a|A) _Save -a ;;
        b|B) _Menu ;;
        v|V) _Save -v ;;
    esac

}

_LittleStars() {

    if [[ $THEME = default ]]; then
        for i in {1..7}; do
            echo -en "\e[38;5;${i}m*****\e[0m"
        done
    else
        # feeding the loop with colors codes from ~/.config/mpm/themerc
        # first test for hex colors else rgb colors
        for i in "${customColors[@]}"; do
            if [[ $i = 0x* ]]; then
                printf '\e[38;2;%d;%d;%dm%s' ${i} '*******'
            else
                echo -en "\e[38;5;${i}m*******\e[0m"
            fi
        done
    fi
    
}

_CheckUpdate() {

    local UPD
    UPD=$(curl -sL "https://raw.githubusercontent.com/archusXIV/mpv-playlists-manager/main/version")
    
    if [[ $check_updates = yes ]]; then
        [[ $UPD != "$VERSION" ]] && \
        printf '%s\n' " ${critical}${b}$UPD available${nb}${nc}"
        
    else
        echo ""
    fi
}

_ListsCount() {

    __col() (
        if [[ -z $(find "$playlists_dir" -not -name "default.m3u" -name "*.m3u") ]]; then
            echo "0"
        else
            echo "${info}$(find "$playlists_dir" -not -name "default.m3u" \
            -name "*.m3u" -printf '.' | wc -c)${nc}"
        fi
    )
    
    __def() (
        if [[ -f $tmp_dir/1 ]]; then
            echo "${critical}${b}$(_GetLinesList -q)${nb}${nc}"
        elif [[ $(_GetLinesList -q) -gt 0 ]]; then
            echo "${info}$(_GetLinesList -q)${nc}"
        else
            echo "0"
        fi
    )
    
    __aud() (
        if [[ -s $AUDIO_URLS ]]; then
            echo "${info}$(_GetLinesList -a)${nc}"
        else
            echo "0"
        fi
    )
    
    __vid() (
        if [[ -s $VIDEO_URLS ]]; then
            echo "${info}$(_GetLinesList -v)${nc}"
        else
            echo "0"
        fi
    )
    
    sep="${task}*${nc}"
    echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐"
    echo -e "                            Collection: $(__col) ${sep} Default list: $(__def) ${sep} Audio list: $(__aud) ${sep} Video list: $(__vid)"
    echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"

}

_ResizeWindow() {
    # width & height are defined in mpmrc
    if [[ -n $width && -n $height ]]; then
        wmctrl -r :ACTIVE: -e 5,-1,-1,"$width","$height"
    else
        wmctrl -r :ACTIVE: -e 5,-1,-1,1260,738
    fi
}

_IfMpvc() {
    
    pgrep -x mpv >/dev/null && {
        
        if [[ $use_mpvc_online = yes ]]; then
            echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐" && \
            echo -e "                  │           ${info}mpv is running, press N to launch the mpv tui or ${task}Q ${info}to quit mpv${nc}            │" && \
            echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"
        elif [[ $use_mpvc_locally = yes ]]; then
            echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐" && \
            echo -e "                  │           ${info}mpv is running, press N to launch the mpv tui or ${task}Z ${info}to quit mpv${nc}            │" && \
            echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"
        else
            echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐" && \
            echo -e "                  │           ${info}mpv is running, press N to launch the mpv tui or ${task}Q ${info}to quit mpv${nc}            │" && \
            echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"
        fi

    }

}

_Menu() {

    cd "$main_dir" || exit 1

    while [[ -e $QUEUE ]]; do
        _ResizeWindow
        clear
        __
        echo -e "                                           ${mtitle}::MPV-PLAYLISTS-MANAGER $VERSION::" "$(_CheckUpdate)"
        echo -e "                                          $(_LittleStars)"
        echo -e "                                        ${info}current theme: $THEME. ${critical}For usage type U${nc}"
        _ListsCount
        echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐"
        echo -e "                  │                      GENERAL OPTIONS                       │     ${mtitle}MPMRC SETTINGS${nc}     │"
        echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"
        echo -e "                  ┌─────────────────────────────────────────────────────────────────────────────────────┐"
        [[ $use_parallel = yes ]] && echo -e "                  │  1) Create/Add video playlist   6) View default playlist   │  use parallel:    ${task}yes${nc}  │" || \
        echo -e "                  │  1) Create/Add video playlist   6) View default playlist   │  use parallel:     ${task}no${nc}  │"
        [[ $direct_download = yes ]] && echo -e "                  │  2) Create/Add audio playlist   7) Clear all tmp lists     │  direct download: ${task}$direct_download${nc}  │"
        [[ $direct_download = no ]] && echo -e "                  │  2) Create/Add audio playlist   7) Clear all tmp lists     │  direct download:  ${task}$direct_download${nc}  │"
        [[ $automatic_audio_conversion = yes ]] && echo -e "                  │  3) Save as/Delete a playlist   8) Edit a playlist         │  conversion auto: ${task}$automatic_audio_conversion${nc}  │"
        [[ $automatic_audio_conversion = no ]] && echo -e "                  │  3) Save as/Delete a playlist   8) Edit a playlist         │  conversion auto:  ${task}$automatic_audio_conversion${nc}  │"
        if [[ -z $default_conversion_format ]]; then echo -e "                  │  4) Play/Download a playlist    ${mtitle}9)${nc} Edit mpm config (mpmrc) │  audio format:  ${task}unset${nc}  │"; \
        elif [[ $default_conversion_format != flac ]]; then echo -e "                  │  4) Play/Download a playlist    ${mtitle}9)${nc} Edit mpm config (mpmrc) │  audio format:    ${task}$default_conversion_format${nc}  │"; \
        elif [[ $default_conversion_format = flac ]]; then echo -e "                  │  4) Play/Download a playlist    ${mtitle}9)${nc} Edit mpm config (mpmrc) │  audio format:   ${task}$default_conversion_format${nc}  │"; fi
        [[ $quit_after_task = yes ]] && echo -e "                  │  5) Load local folder/files     X) Exit                    │  quit after task: ${task}$quit_after_task${nc}  │"
        [[ $quit_after_task = no ]] && echo -e "                  │  5) Load local folder/files     X) Exit                    │  quit after task:  ${task}$quit_after_task${nc}  │"
        echo -e "                  └─────────────────────────────────────────────────────────────────────────────────────┘"
        _IfMpvc
        [[ -f $tmp_dir/1 ]] \
            && echo -e "                                                     ${info}Select an item${nc}" \
            || echo -e "                                                     ${info}${b}Select an item${nc}${nb}"
        __
        read -rsn 1 mainMenuOptions
        case "$mainMenuOptions" in
            1)  _CopyUrl -v
                __  ;;
            2)  _CopyUrl -a
                __  ;;
            3)  _SaveRemove
                __  ;;
            4)  _LoadPlaylist
                __  ;;
            5)  _LoadLocal
                __  ;;
            6)  _ViewUrlInfo -q
                __  ;;
            7)  _DeleteUrls
                __  ;;
            8)  _EditPlaylist
                __  ;;
            9)  _EditMpmConf
                __  ;;
            n|N)
                if [[ $use_mpvc = yes ]] && [[ -n $mpvc_tui ]]; then
                    "$mpvc_tui"
                else
                    printf '%s\n' " ${critical}No mpv interface setup in your config..." \
                    " use_mpvc must be set to 'yes' or mpvc_tui is empty${nc}"
                    sleep 5
                    continue
                fi
            ;;
            q|Q)
                pgrep -x mpv >/dev/null && {
                    kill -SIGTERM "$(pidof mpv)"
                    rm "$tmp_dir"/{nowPlaying,temporary*} 2>/dev/null
                }
                ;;
            u|U)
                less "$HELP"
            ;;
            x|X)
                __;__
                if [[ -s "$AUDIO_URLS" || -s "$VIDEO_URLS" ]]; then
                    _SaveOnExit
                else
                    nc=$'\e[0m';
                    echo "${nc}"
                    clear
                    exit
                fi
            ;;
            z|Z)
                # we now exit the subshell not the program
                pgrep -x mpv >/dev/null && {
                    kill -SIGTERM "$(pidof mpv)"
                    exit 0
                }
            ;;
            *)
                __
                printf '%s\n' " ${critical}Wrong option $mainMenuOptions...${nc}"
                sleep 3s && continue
            ;;
        esac
    done
}

YTOP="$tmp_dir/youtube-dl_output"
FFOP="$tmp_dir/ffmpeg_output"
DEFAULTITLES="$tmp_dir/DefaultTitles"
DEFAULTM3UTITLES="$titles_dir/default.m3u.titles"

_ConvertAudio_flac() {
    for f in "${webmFiles[@]}"; do
        ffmpeg -i "${f}" \
        "${ffmpegFlacCodecOptions[@]}" \
        -y "${f%.webm}.flac" 2>"$FFOP"
    done
}

_ConvertAudio_mp3() {
    for m in "${webmFiles[@]}"; do
        ffmpeg -i "${m}" \
        "${ffmpegMp3CodecOptions[@]}" \
        -y "${m%.webm}.mp3" 2>"$FFOP"
    done
}

_ConvertAudio_ogg() {
    for o in "${webmFiles[@]}"; do
        ffmpeg -i "${o}" \
        "${ffmpegOggCodecOptions[@]}" \
        -y "${o%.webm}.ogg" 2>"$FFOP"
    done
}

_ConvertAudio_wav() {
    for w in "${webmFiles[@]}"; do
        ffmpeg -i "${w}" \
        "${ffmpegWavCodecOptions[@]}" \
        -y "${w%.webm}.wav" 2>"$FFOP"
    done
}

_ConvertAudio() {

    local webmFiles
    [[ -d "$audios_dir"/"${list%.*}" ]] \
    && cd "$audios_dir"/"${list%.*}" \
    || cd "$audios_dir"

    mapfile -t webmFiles < <(find "$audios_dir" -maxdepth 2 -iname "*.webm")

    if [[ -n $default_conversion_format ]]; then
        __
        printf '%s\n' \
        " ${info}Conversion format set to $default_conversion_format."
        __
        printf '%s\n' \
        " Converting files in ${task}${b}$default_conversion_format...${nb}"
        __
        if [[ -n $(command -v parallel) && $use_parallel = yes ]]; then
            printf '%s\n' " Parallel conversion enabled."
            parallel --delay 2.5 -j+0 \
            ffmpeg -y -i {} -qscale:a 0 {.}."$default_conversion_format" ::: ./*.webm 2>"$FFOP"
        else
            printf '%s\n' " Parallel conversion disabled.${nc}"
            _ConvertAudio_"$default_conversion_format"
        fi
    else
        __
        printf '%s\n' " ${critical}Conversion format isn't set..." \
        " ${info}Press Enter to abort conversion.${nc}"
        declare -A formats=(
            [1]="flac"
            [2]="mp3"
            [3]="ogg"
            [4]="wav"
        )
        __
        read -rn1 \
        -p " ${info}Select an output format [1=flac] [2=mp3] [3=ogg] [4=wav]: ${nc}"
        
        case "$REPLY" in
            [1-4])
                __
                printf '%s\n' \
                " ${info}Converting files in ${task}${b}${formats[${REPLY}]}...${nb}"
                __
                if [[ -n $(command -v parallel) && $use_parallel = yes ]]; then
                    printf '%s\n' " Parallel conversion enabled."
                    parallel --delay 2.5 -j+0 \
                    ffmpeg -y -i {} -qscale:a 0 {.}."${formats[${REPLY}]}" ::: ./*.webm 2>"$FFOP"
                else
                    printf '%s\n' " Parallel conversion disabled.${nc}"
                    _ConvertAudio_"${formats[${REPLY}]}"
                fi
            ;;
            *)
                __
                find "$audios_dir" -maxdepth 2 -name "*.webm" >/dev/null && {
                    mv ./*.webm "$MUSIC_DIR"
                    printf '%s\n' " ${critical}Conversion aborted," \
                    " All .webm files have been moved in $MUSIC_DIR.${nc}"
                    sleep 3
                } || printf '%s\n' " ${critical}Wrong format $REPLY...${nc}"
                __
                sleep 3
                return
            ;;
        esac
        
    fi

    find . -iname "*.webm" -exec rm {} \; && \
    __ && printf '%s\n' " ${info}Conversion done.${nc}" \
    && sleep 2
}

_GetAudioDownloadMessages() {

    [[ $M3UFILE = "$AUDIO_URLS" ]] && {
        printf '%s\n' " ${info}$(_GetLinesList -a) audio file(s) left to download." \
        " Downloading:  $(_GetLinkTitle -a)" \
        " ${task}Searching for webm format...${nc}"
    }

    [[ $M3UFILE = "$playlists_dir"/"$list" ]] && {
        printf '%s\n' " ${info}$(_GetLinesList -l) audio file(s) left to download." \
        " Downloading:  $(_GetLinkTitle -l)" \
        " ${task}Searching for webm format...${nc}"
    }

    [[ $M3UFILE = "$QUEUE" ]] && {
        printf '%s\n' " ${info}$(_GetLinesList -q) audio file(s) left to download." \
        " Downloading:  $(_GetLinkTitle -q)" \
        " ${task}Searching for webm format...${nc}"
    }

}

# these are temporary files used in _Choose{Download{Audio,Video},FromPlay}
CHOOSE1="$tmp_dir/temporarySelection.m3u"
CHOOSE2="$tmp_dir/temporarySelection2.m3u"

_IfWebmFiles() {
    if [[ -n $(find "$audios_dir" -maxdepth 2 -iname "*.webm") ]]; then

        echo " ${critical}ADVISORY: if you choose conversion, all downloaded files (.webm)"
        echo -e " will be converted in the chosen format.${nc}\n"
        find "$audios_dir" -maxdepth 2 -iname "*.webm" | sed 's,.*/,,' | sort | cat -n

        if [[ $automatic_audio_conversion = yes ]]; then
            __
            printf '%s\n' " ${task}Automatic audio conversion enabled.${nc}"
            sleep 2
            [[ $M3UFILE = "$AUDIO_URLS" ]] || [[ $M3UFILE = "$QUEUE" ]] \
            && _ConvertAudio && _GetCompleted -a
            [[ $M3UFILE = "$playlists_dir"/"$list" ]] || [[ $M3UFILE = "$CHOOSE1" ]] \
            && _ConvertAudio && _DownloadCompleted
        else
            __
            _Prompt " ${info}Proceed with conversion?: ${nc}" || {
                mv ./*.webm "$MUSIC_DIR"
                printf '%s\n' " ${critical}All .webm files have been moved in $MUSIC_DIR.${nc}"
                sleep 3
                [[ $M3UFILE = "$AUDIO_URLS" ]] || [[ $M3UFILE = "$QUEUE" ]] \
                && _GetCompleted -a
                [[ $M3UFILE = "$playlists_dir"/"$list" ]] || [[ $M3UFILE = "$CHOOSE1" ]] \
                && _DownloadCompleted
            }
            [[ $M3UFILE = "$AUDIO_URLS" ]] || [[ $M3UFILE = "$QUEUE" ]] \
            && _ConvertAudio && _GetCompleted -a
            [[ $M3UFILE = "$playlists_dir"/"$list" ]] || [[ $M3UFILE = "$CHOOSE1" ]] \
            && _ConvertAudio && _DownloadCompleted
        fi

    else
        [[ $M3UFILE = "$AUDIO_URLS" ]] || [[ $M3UFILE = "$QUEUE" ]] \
        && _GetCompleted -a
        [[ $M3UFILE = "$playlists_dir"/"$list" ]] || [[ $M3UFILE = "$CHOOSE1" ]] \
        && _DownloadCompleted
    fi
}

_YtdlGetTitle() {
    youtube-dl --skip-download --get-title "${ytdlPreset_DW[@]}" "$1"
}

_GetMediaTitle() {

    case "$1" in
        -a) LIST="$AUDIO_URLS" ;;
        -l) LIST="$playlists_dir"/"$list" ;;
        -q) LIST="$QUEUE" ;;
        -v) LIST="$VIDEO_URLS" ;;
    esac

    while read -r line; do
        _YtdlGetTitle "$line" 2>/dev/null
    done < <(grep '^https' "$LIST")

}

_GetAudioDownload() {
    
    mapfile -t AUDIOLINKS < <(grep '^https' "$M3UFILE")
    
    for getAudioUrl in "${AUDIOLINKS[@]}"; do
        _GetAudioDownloadMessages
        if [[ $(youtube-dl -F "${ytdlPreset_DW[@]}" "$getAudioUrl" \
            | grep '^251') ]]; then
            __
            if [[ $(sed -n '1p' "$TITLES") =~ '/' ]]; then
                youtube-dl --format 251 "${ytdlPreset_FS[@]}" \
                "${ytdlPreset_NC[@]}" "$getAudioUrl"
            else
                youtube-dl --output "$(sed -n '1p' "$TITLES").%(ext)s" \
                --format 251 "${ytdlPreset_NC[@]}" "$getAudioUrl"
            fi
        else
            youtube-dl -F "${ytdlPreset_DW[@]}" "$getAudioUrl" \
            | awk '/audio only|PROTO|^[-]/ {sub("^[sb*]",""); print $0}'
            __
            printf '%s\n' " ${info}Choose a format code: ${nc}"
            read -r code
            clear
            __
            if [[ $(sed -n '1p' "$TITLES") =~ '/' ]]; then
                youtube-dl --format "$code" "${ytdlPreset_FS[@]}" \
                "${ytdlPreset_NC[@]}" "$getAudioUrl"
            else
                youtube-dl --output "$(sed -n '1p' "$TITLES").%(ext)s" \
                --format "$code" "${ytdlPreset_NC[@]}" "$getAudioUrl"
            fi
        fi

        if [[ $M3UFILE = "$AUDIO_URLS" ]]; then
            sed -i '1d' {"$M3UFILE","$TITLES"}
        else
            sed -i '2d' "$M3UFILE"
            sed -i '1d' "$TITLES"
        fi

        clear

    done
}

_GetAudio() {

    cd "$audios_dir" || exit 1
    local AUDIO_DIR M3UFILE TITLES

    case "$1" in
        -a)
            [[ $(_GetLinesList -a) -eq 0 ]] && {
                printf '%s\n' " ${critical}No links in the $Type list${nc}"
                sleep 2
                return
            }
            AUDIO_DIR="$audios_dir"
            M3UFILE="$AUDIO_URLS"
            TITLES="$AUDIO_TITLES"
        ;;
        -l)
            AUDIO_DIR="$audios_dir"/"${list%.*}"
            M3UFILE="$playlists_dir"/"$list"
            TITLES="$titles_dir"/"$list".titles
        ;;
        -q)
            if [[ ! -f $DEFAULTITLES && \
                -f $DEFAULTM3UTITLES ]]; then
                cat "$DEFAULTM3UTITLES" > \
                "$DEFAULTITLES"
            elif [[ -f $DEFAULTITLES ]]; then
                printf '%s\n' " ${info}Fetching titles file...${nc}"
                sleep 1
            else
                printf '%s\n' " ${info}Getting titles...${nc}"
                _GetMediaTitle -q > "$DEFAULTITLES"
                clear
            fi
            AUDIO_DIR="$audios_dir"
            M3UFILE="$QUEUE"
            TITLES="$DEFAULTITLES"
        ;;
    esac

    cp -f "$M3UFILE" "$M3UFILE"_origin
    cp -f "$TITLES" "$TITLES"_origin
    clear

    [[ ! -d $AUDIO_DIR ]] && {
        mkdir --parents "$AUDIO_DIR"
        cd "$AUDIO_DIR"
    } || cd "$AUDIO_DIR"

    _GetAudioDownload

    echo -e " ${info}Done\n${nc}"

    _IfWebmFiles

}

_ViewUrlInfo() {

    local stars

    viewUrlInfoPrompt=(
        "[M]aim menu," "[A]dd more links," "[D]ownload,"
        "[P]lay," "[S]ave as," "[R]emove links/list: "
    )

    # let's play...
    stars=$(printf "%-54s" "*")
    
    __audioVideoCommon() (
        clear
        __
        echo " ${info}ORDER |  $menuTitleType PLAYLIST LINKS & TITLES.${nc}"
        echo -e " ${info}${stars// /*}${nc}\n"
        awk '$0 ~ /^https/{print $0}' "$menuTitleType_$URLS" \
        | nl && {
            __
            nl "$menuTitleType_$TITLES"
        __
        }
        echo "${info}" "${viewUrlInfoPrompt[@]}" "${nc}"
    )

    # Normaly in Bash nested functions use parentheses instead of curly braces,
    # but here it won't work because of the case statment right parenthese...
    # They will close the block before it finishes.
    __audio() {
        if [[ -s $URLS ]]; then
            __audioVideoCommon
            read -rsn 1 audioOptions
            case "$audioOptions" in
                a|A) __; _CopyUrl -a ;;
                m|M) _Menu ;;
                d|D) _GetAudio -a ;;
                p|P) _LoadAudioVideo -a ;;
                r|R) _Remove -a ;;
                s|S) _Save -a ;;
            esac
        else
            echo " ${critical}No links in the $Type list${nc}"
            sleep 2 && return
        fi
    }

    __video() {
        if [[ -s $URLS ]]; then
            __audioVideoCommon
            read -rsn 1 videoOptions
            case "$videoOptions" in
                a|A) __; _CopyUrl -v ;;
                m|M) _Menu ;;
                d|D) _GetVideo -v ;;
                p|P) _LoadAudioVideo -v ;;
                r|R) _Remove -v ;;
                s|S) _Save -v ;;
            esac
        else
            echo " ${critical}No links in the $Type list${nc}"
            sleep 2 && return
        fi
    }

    __queue() {
        if (($(_GetLinesList -q) > 0)); then
            rm "$tmp_dir"/1 2>/dev/null
            
            [[ $(grep "" -c "$DEFAULTITLES") -ne $(_GetLinesList -q) ]] && {
                printf '%s\n' " ${critical}Default list as been modified," \
                " ${task}${b}Updating Default list titles...${nb}${nc}"
                _GetMediaTitle -q > "$DEFAULTITLES"
            }
            clear
            __
            echo " ${info}ORDER |  DEFAULT PLAYLIST LINKS & TITLES.${nc}"
            echo -e " ${info}${stars// /*}${nc}\n"
            awk '$0 ~ /^https/{print $0}' "$QUEUE" \
            | nl && {
                __
                nl "$DEFAULTITLES"
                __
            }
            
            while [[ -f $QUEUE ]]; do
                unset 'viewUrlInfoPrompt[1]'
                echo "${info}" "${viewUrlInfoPrompt[*]}" "${nc}"
                read -rsn 1 queueOptions
                case "$queueOptions" in
                    d|D)
                        __
                        read -rsn 1 -p "${info}"' Download [A]udio, [V]ideo:'"${nc}" get
                        case "$get" in
                            a|A) __; _GetAudio -q ;;
                            v|V) __; _GetVideo -q ;;
                        esac
                    ;;
                    m|M)
                        _Menu
                    ;;
                    p|P)
                        __
                        read -rsn 1 -p "${info}"' Play [A]udio, [V]ideo?: '"${nc}" play
                        case "$play" in
                            a|A) _LoadAudioVideo -qa ;;
                            v|V) _LoadAudioVideo -qv ;;
                        esac
                    ;;
                    r|R) _Remove -q ;;
                    s|S)
                        if [[ -f $DEFAULTM3UTITLES \
                            || -f  $DEFAULTITLES ]]; then
                            _Save -q
                        else
                            printf '%s\n' " ${task}${b}Updating Default list titles...${nb}${nc}"
                            _GetMediaTitle -q \
                            | tee -a "$DEFAULTITLES" \
                            | cat -n >/dev/null 2>&1
                            _Save -q
                        fi
                    ;;
                esac
            done
        else
            echo " ${critical}There is nothing to do, Default playlist is empty...${nc}"
            sleep 3
        fi
    }

    case "$1" in
        -a) __audio ;;
        -v) __video ;;
        -q) __queue ;;
    esac
}

_RemoveCrap() {
    # After some tests it appears that a single link copied from a youtube playlist
    # causes the download of the entire playlist.
    # So with sed & perl we cleanup the link to get the direct link to the desired video.
    # Note that this behavior does not appear during a simple viewing/listening.

    LISTS=(
        "$AUDIO_URLS" "$AUDIO_TITLES"
        "$VIDEO_URLS" "$VIDEO_TITLES"
        "$QUEUE" "$DEFAULTITLES"
    )

    for file in "${LISTS[@]}"; do
        # removing unwanted parts of links, blank lines & duplicates
        # we use commas as separators.
        sed -i 's/&list.*//;/^\s*$/d;s|//youtube.com|//www.youtube.com|g' "$file"
        perl -i -ne 'print if ! $a{$_}++' "$file"
    done 2>/dev/null

}

_CleanTmpDir() {
    
    cd "$tmp_dir" || exit 1
    
    if [[ -s "$DEFAULTITLES" ]]; then
        cp -f "$DEFAULTITLES" "$DEFAULTM3UTITLES"
    elif [[ -f "$DEFAULTM3UTITLES" && ! -f "$DEFAULTITLES" ]]; then
        rm "$DEFAULTM3UTITLES"
    fi

    if pgrep -x mpv >/dev/null; then
        find . -type f \
        -not -name "$(awk -F"/" '{print $NF}' "$NOWPLAYING")" \
        -not -name 'nowPlaying' -exec rm {} \;
        rm -f \
        "$playlists_dir"/{1_Back_to_menu,*_tmp} 2>/dev/null
    else
        rm -f \
        {"$tmp_dir"/*,"$playlists_dir"/{1_Back_to_menu,*_tmp}} 2>/dev/null
    fi
    
}

_DeleteUrls() {

    cd "$tmp_dir" || exit 1

    declare -a tmps=(
        "$AUDIO_URLS" "$AUDIO_TITLES"
        "$VIDEO_URLS" "$VIDEO_TITLES"
        "$FFOP" "$YTOP" "$DEFAULTITLES"
        "$NOWPLAYING" "$tmp_dir/1" "$CHOOSE1"
        "Audio" "Video" "default" "temporarySelection"
    )

    __deleteUrlsWarnings() (
        if [[ -f $NOWPLAYING && $(find . -name "*.m3u" | wc -l) -ge 1 ]]; then
            __
            printf '%s\n' " ${critical}All Temporary lists cleared," \
            " except $(awk -F"/" '{print $NF}' "$NOWPLAYING").${nc}"
            sleep 4
        else
            __
            printf '%s\n' " ${critical}No Temporary lists found," \
            " except $(awk -F"/" '{print $NF}' "$NOWPLAYING")." \
            " First quit mpv then try again.${nc}"
            sleep 5
        fi
        rm "${tmps[@]}" 2>/dev/null
    )
    
    if [[ -f $NOWPLAYING ]]; then
        for w in "${tmps[@]:10:13}"; do
            if [[ $(awk -F"/" '{print $NF}' "$NOWPLAYING") =~ $w ]]; then
                [[ $w = "${tmps[10]}" ]] && {
                    unset {tmps[0],tmps[1],tmps[7]}
                    sed -i '/^[[:alpha:]]/d' "$QUEUE"
                }
                [[ $w = "${tmps[11]}" ]] && {
                    unset {tmps[2],tmps[3],tmps[7]}
                    sed -i '/^[[:alpha:]]/d' "$QUEUE"
                }
                [[ $w = "${tmps[12]}" ]] && unset {tmps[6],tmps[7]}
                [[ $w = "${tmps[13]}" ]] && {
                    unset {tmps[7],tmps[8]}
                    sed -i '/^[[:alpha:]]/d' "$QUEUE"
                }
            fi
        done
        __deleteUrlsWarnings
    else
        sed -i '/^[[:alpha:]]/d' "$QUEUE"
        rm "${tmps[@]}" 2>/dev/null
        printf '%s\n' " ${critical}All Temporary lists cleared.${nc}"
        sleep 2
    fi

    _Menu
}

YTSEARCH="$tmp_dir/youtubeSearch"

_SearchYoutubeWithFzf() {

    ! command -v fzf >/dev/null && {
        __
        printf '%s\n' " ${critical}fzf package is not installed...${nc}"
        sleep 2
        return
    }

    local sanitizedRequest sanitizedResult grabLink grabPlaylist IDS id selection \
    mediaLinkIDS mediaPrefix playlistLinkIDS playlistPrefix

    if [[ -z $* ]]; then
        __
        printf '%s\n' " ${critical}Tip: To copy links in the fzf menu press ${task}Enter" \
        " ${critical}on the desired ${Type} titles (can be a playlist)," \
        " note that multi selection is not implemented" \
        " so ${task}press Enter ${critical}on each title and then press ${task}Escape ${critical}to confirm.${nc}"
        __
        read -rp " ${info}Search for youtube ${Type} (no quotes): ${nc}" request
    else
        request="$*"
    fi

    [[ -z $request ]] && return

    sanitizedRequest=$(
        sed -e '
        s/+/%2B/g;s/#/%23/g;s/&/%26/g;s/\s/+/g
        ' <<< "$request"
    )

    sanitizedResult=$(
        curl \
        -s "https://www.youtube.com/results?search_query=${sanitizedRequest}" | \
        sed 's/\\.//g'
    )

    if ! grep -q "$sanitizedRequest" <<< "$sanitizedResult"; then
        echo "unable to reach youtube.com"
        sleep 2s
        return
    fi

    grabLink='"videoRenderer":{"videoId":"\K.{11}".+?"text":".+?[^\\](?=")'
    grabPlaylist='"playlistRenderer":{"playlistId":"\K.{34}?","title":{"simpleText":".+?[^\"](?=")'

    __getResults() (
        grep -oP "$1" <<< "$sanitizedResult" | \
        awk -F\" -v p="$2" '{ print $1 "\t" p " " $NF}'
    )

    mediaLinkIDS=$(__getResults "$grabLink" "[${Type}]")
    playlistLinkIDS=$(__getResults "$grabPlaylist" "[Playlist]")

    [[ -n $playlistLinkIDS ]] && IDS="$playlistLinkIDS\n"
    [[ -n $mediaLinkIDS ]] && IDS="$IDS$mediaLinkIDS"

    mediaPrefix="https://www.youtube.com/watch?v="
    playlistPrefix="https://www.youtube.com/playlist?list="

    while true; do
        selection=$(echo -e "$IDS" | cut -d'	' -f2 \
        | fzf \
        --prompt='Filter: ' \
        --header "${info}${b}"'Press Enter to copy, Escape to confirm & exit search: '"${nb}${nc}")

        # grep a fixed string that is a word and matches only one line in selection.
        id=$(echo -e "$IDS" | grep -Fwm1 "$selection" | cut -d'	' -f1)

        if [[ -z $selection ]]; then
            return
        else
            notify-send "copied: $(echo -e "$selection" | sed "s/\[.*\]\s//")"
        fi

        case "$id" in
            # 11 digits id = media
            ???????????)
                echo "$mediaPrefix$id" | tee -a "$URLS" >> "$QUEUE"
                echo -e "$selection" | sed "s/\[.*\]\s//" \
                | tee -a "$TITLES" >> "$DEFAULTITLES"
                _RemoveCrap
            ;;
            # 34 digits id = playlist
            ??????????????????????????????????)
                echo "$playlistPrefix$id" >> "$YTSEARCH"
            ;;
            *)
                return
            ;;
        esac
    done
}

_SearchOnlineWithYtfzf() {
    __
    printf '%s\n' " ${critical}Tip: To select mutiple links in the ytfzf menu press ${task}Tab" \
    " ${critical}on the desired ${Type} titles, ${task}Ctrl P${critical} to view next page...etc" \
    " then ${task}Enter ${critical}to confirm and go back in $menuTitleType OPTIONS menu.${nc}"
    __
    read -rp " ${info}Search for online ${Type} links: ${nc}" request

    if [[ -n $request ]]; then
        # ytfzf_options are defined in mpmrc
        ytfzf -tL "${ytfzfOptions_X[@]}" "$request$*" >> "$URLS"

        clear
        [[ ! -s $URLS ]] && return

        while read -r line; do

            if [[ $line =~ 'playlist?list=' ]]; then
                echo "$line" >> "$YTSEARCH"
            else
                echo "$line" >> "$QUEUE"
                __
                printf '%s\n' " ${info}Getting $line title...${nc}"
                _YtdlGetTitle "$line" | tee -a "$TITLES" >> "$DEFAULTITLES"
                sleep 1
                clear
            fi

        done < "$URLS"

        _RemoveCrap

    else
        return
    fi
}

_SearchOnline() {
    __
    command -v ytfzf >/dev/null && {
        read -rsn1 \
        -p " ${info}Search ${Type} with regular [f]zf or [y]tfzf script?: ${nc}" \
        searchOnlineOptions
        
        case "$searchOnlineOptions" in
            f|F)
                _SearchYoutubeWithFzf
            ;;
            y|Y)
                _SearchOnlineWithYtfzf
            ;;
            *)
                __; printf '%s\n' " ${critical}Wrong option $searchYoutubeOptions...${nc}"
                sleep 3
                clear
            ;;
        esac
    } || _SearchYoutubeWithFzf

}

_GetYoutubePlaylistUrls() {

    __AudioVideoPlaylist() (
        youtube-dl "${ytdlPreset_DW[@]}" -j "$mediaUrl" \
        | jq '(.webpage_url)' | sed 's/"//g' \
        | tee -a "$QUEUE" >> "$URLS"
        sed -i '/playlist/d' {"$QUEUE","$URLS"}
    )

    case "$1" in
        -a)
            __AudioVideoPlaylist
        ;;
        -s)
            mapfile -t < <(grep '^https' "$YTSEARCH")
            # there might be several playlists urls selected in 
            # _Search{Online,Youtube}With functions so we enter in a loop.
            for url in "${MAPFILE[@]}"; do

                __
                printf '%s\n' \
                " ${info}Please be patient while extracting urls/titles from:" \
                " $(youtube-dl "${ytdlPreset_DW[@]}" -J --flat-playlist \
                "$(sed -n '1p' "$YTSEARCH")" | jq -r .title) playlist...${nc}"

                youtube-dl "${ytdlPreset_DW[@]}" -j "$url" \
                | jq '(.webpage_url)' | sed 's/"//g' \
                | tee -a "$QUEUE" >> "$URLS"
                
                _YtdlGetTitle "$(sed -n '1p' "$YTSEARCH")" \
                | tee -a "$TITLES" >> "$DEFAULTITLES"
                sed -i '1d' "$YTSEARCH"
                clear
                
            done
            
            sed -i '/playlist/d' {"$QUEUE","$URLS"}
            _RemoveCrap

            rm "$YTSEARCH"; sleep 1s

            clear && return
        ;;
        -v)
            __AudioVideoPlaylist
        ;;
    esac

}

_CopyUrl() {

    local Type TITLES URLS menuTitleType arg mediaUrl
    
    [[ -f $tmp_dir/1 ]] && rm "$tmp_dir"/1

    case "$1" in
        -a)
            Type=Audio
            TITLES="$AUDIO_TITLES"
            URLS="$AUDIO_URLS"
            menuTitleType=AUDIO
            arg="-a"
        ;;
        -v)
            Type=Video
            TITLES="$VIDEO_TITLES"
            URLS="$VIDEO_URLS"
            menuTitleType=VIDEO
            arg="-v"
        ;;
    esac

    while (( $(grep "" -c "$QUEUE") > 0 )); do
    
        __CopyLinks() (
            __
            echo -e " Paste an url to fill the ${info}${Type}${nc} playlist:\n"
            read -r mediaUrl

            if [[ $mediaUrl =~ 'playlist?list=' ]]; then
                __
                printf '%s\n' " ${info}Getting titles & links from playlist: $(\
                youtube-dl "${ytdlPreset_DW[@]}" -J --flat-playlist "$mediaUrl" \
                | jq -r .title)..." \
                "${b} Please be patient.${nb}${nc}"
                
                _YtdlGetTitle "$mediaUrl" \
                | tee -a "$TITLES" >> "$DEFAULTITLES"
                _GetYoutubePlaylistUrls $arg
                _RemoveCrap
            else

                echo "$mediaUrl" >> "$URLS"
                __
                echo -e " ${info}Testing url...${nc}"
                _RemoveCrap
                mediaUrl=$(sed -n '$p' "$URLS")
                youtube-dl -F "${ytdlPreset_DW[@]}" "$mediaUrl" > "$YTOP"

                if [[ $? -eq 1 ]]; then
                    __
                    echo -e " ${critical}${b}No format code found!${nb}\n$mediaUrl will be removed."
                    echo " ${info}Please visit: $supportedSites${nc}"
                    sed -i '$d' "$URLS"
                    _RemoveCrap
                    sleep 7
                    [[ $(_GetLinesList $arg) -eq 0 ]] && return
                else
                    echo "$mediaUrl" >> "$QUEUE"
                    echo -e " ${info}Getting ${Type} title...${nc}\n"
                    _YtdlGetTitle "$mediaUrl" \
                    | tee -a "$TITLES" >> "$DEFAULTITLES"
                    _RemoveCrap
                fi

            fi
        )
        
        while true; do
            _ResizeWindow
            clear
            
            [[ -s $YTSEARCH ]] \
            && _GetYoutubePlaylistUrls -s
            __
            [[ -s $URLS ]] && \
            echo -e " ${info}${Type} list: $(_GetLinesList $arg) url(s)${nc}"
            __
            echo -e "                                                  ${mtitle}::${menuTitleType} OPTIONS::${nc}"
            echo -e "                               ┌──────────────────────────────────────────────────────┐"
            echo -e "                               │   1) Add ${Type} links         5) Play current list    │"
            command -v fzf >/dev/null || echo -e "                               │   2) ${critical}Search online links ${nc}    6) View current list    │" \
            && echo -e "                               │   2) Search online links     6) View current list    │"
            echo -e "                               │   3) Download current list   7) Back to main menu    │"
            echo -e "                               │   4) Save/Add current list                           │"
            echo -e "                               └──────────────────────────────────────────────────────┘"
            [[ -s $URLS ]] \
            && echo -e "                                                   ${info}Select an item${nc}" \
            || echo -e "                                                   ${info}${b}Select an item${nb}${nc}"
            __
            read -rsn 1 copyUrlsOptions
            case "$copyUrlsOptions" in
                1)  __CopyLinks
                    __ ;;
                2)
                    if [[ $use_fzf = yes ]]; then
                        clear
                        _SearchOnline
                    else
                        __
                        printf '%s\n' \
                            " ${critical}fzf is set to NO in your mpmrc file..." \
                            " no way to search on youtube!${nc}"
                        sleep 5
                    fi
                ;;
                3)
                    [[ $arg = '-a' ]] && _GetAudio -a || _GetVideo -v
                    __ ;;
                4)  _Save $arg
                    __ ;;
                5)  [[ -n $(pidof mpv) ]] && {
                        printf '%s\n' " ${critical}mpv is already running...${nc}"
                        sleep 2
                    } || _LoadAudioVideo $arg
                    __ ;;
                6)  _ViewUrlInfo $arg
                    __ ;;
                7)  _Menu
                    __ ;;
                *)
                    printf '%s\n' " ${critical}Wrong option $copyUrlsOptions...${nc}"
                    sleep 3s && continue
                ;;
            esac
            
        done

    done

}

# triggers a polybar module showing total number of collection playlists
_mpmIpc() {
	polybar-msg \
	-p $(pgrep --full "$(wmctrl -m | awk '/Name:/{print $2}')"-bar-3) \
	action "#mpm-ipc.hook.0" >/dev/null 2>&1
}

_RenameTmpFiles() {

    tmpFiles=(
        "$AUDIO_URLS" "$AUDIO_TITLES"
        "$VIDEO_URLS" "$VIDEO_TITLES"
        "$DEFAULTITLES" "$QUEUE"
    )

    for f in "${tmpFiles[@]}"; do
        [[ ! -f $f ]] && continue
        mv -f "$f"_origin "$f"
    done 2>/dev/null

}

_IfPartsExist() {

    __IfPartsExistInfo() (
        clear
        echo -e " ${critical}Incomplete files in audio/video directories:\n${nc}"
        find {"$audios_dir","$videos_dir"} -name "*.part" 2>/dev/null \
        | sort -d | sed 's,.*/,,' | cat -n
        __
        echo " ${info}Try again now or later, choose an option.${nc}"
        __
        return
    )

    case "$1" in
        -l)
            mv "$playlists_dir"/"$list"_origin \
            "$playlists_dir"/"$list"
            mv "$titles_dir"/"$list".titles_origin \
            "$titles_dir"/"$list".titles
            __IfPartsExistInfo
        ;;
        -t)
            _RenameTmpFiles
            __IfPartsExistInfo
        ;;
    esac

}

_DownloadCompleted() {
    cd "$playlists_dir" || exit 1

    if [[ -n $(find {"$audios_dir","$videos_dir"} -name "*.part") ]]; then
        _IfPartsExist -l
    else
        FILES=( "$list" "$list"_origin "$titles_dir"/"$list".titles \
                "$titles_dir"/"$list".titles_origin "$CHOOSE1" "$CHOOSE2" )

        __KeepItOrNot() (
            if [[ $keep_none_empty_playlist = yes ]]; then
                unset {FILES[0],FILES[2]}
                rm -f "${FILES[@]}" 2>/dev/null
            else
                echo -e " ${critical}keep_none_empty_playlist is set to 'no'.${nc}\n"
                _Prompt \
                " ${info}Downloads completed but $list is not empty, do you want to KEEP it?: ${nc}" || {
                    rm -f "${FILES[@]}" 2>/dev/null
                    _mpmIpc
                    printf '%s\n' " ${critical}$list removed...${nc}"
                    sleep 3
                }
                unset {FILES[0],FILES[2]}
                rm -f "${FILES[@]}" 2>/dev/null
            fi
        )

        # _GetLinesList only counts lines starting with 'https'
        if (( $(_GetLinesList -l) > 0 )); then
            __KeepItOrNot
        else
            printf '%s\n' " ${info}Downloads completed," \
            " ${critical}$list is empty... $list removed.${nc}"
            sleep 3
            rm -f "${FILES[@]}" 2>/dev/null
            _mpmIpc
        fi
        rm -rf "$HOME"/.parallel 2>/dev/null
        [[ $quit_after_task = yes ]] && exit || _Menu
    fi
}

SELECTEDTITLES="$titles_dir/selected.titles"

_GetLinkTitle() {
    case "$1" in
        -a) sed -n '1p' "$AUDIO_TITLES" ;;
        -l) sed -n '1p' "$titles_dir"/"$list".titles ;;
        -q) sed -n '1p' "$DEFAULTITLES" || \
            sed -n '1p' "$DEFAULTM3UTITLES" ;;
        -s) sed -n '1p' "$SELECTEDTITLES" ;;
        -v) sed -n '1p' "$VIDEO_TITLES" ;;
    esac
}

_GetRange() {
    
    cd "$playlists_dir" || exit 1
    grep -v '#EXTM3U' "$list" > "$list"_tmp
    rangePrompt=$(printf '%s\n' "Enter numbers separeted by commas or a dash for a range" \
    " for example: ${task}1-4,6 8-11 or 1-4,6-8,10 or 2,3,5,6,1 : ${nc}")
    __
    IFS=", "; read -ra array -p " ${info}""$rangePrompt""${nc}"
    
    for range in "${array[@]}"; do
        IFS="-"; read -r start end <<< "$range"
        [[ -z $start ]] && continue
        [[ -z $end ]] && end="$start"
        
        for ((i=start;i <= end;i++)); do
            sed -n "${i}p" "$list"_tmp >> "$CHOOSE1"
            sed -n "${i}p" "$titles_dir"/"$list.titles" \
            >> "$SELECTEDTITLES"
        done

    done

    rm "$list"_tmp

}

_DownloadVideoList() {
    cd "$playlists_dir" || exit 1

    _TitlesListCompare
    local counter

    if [[ $direct_download = yes ]]; then
        clear
        _DirectVideoDownload
    else
        clear
        printf '%s\n' " ${task}Direct download disabled."
        __
        printf '%s\n' " ${critical}Tip: direct download will always pick the best format," \
        " on Youtube webm may be the best one but we'll merge files in mp4."
        echo -e " ${info}[B]ack to download options, choose [S]pecific codes or [D]irect download?:\n${nc}"
        read -rsn 1 choice
    fi

    case "$choice" in
        b|B) clear; return ;;
        d|D) clear; _DirectVideoDownload ;;
        s|S)
            clear
            cp -f "$list" "$list"_origin
            mkdir --parents "$videos_dir"/"${list%.*}" \
            && cd "$videos_dir"/"${list%.*}"
            
            mapfile -t SELECTEDCODES < <(grep '^https' "$playlists_dir"/"$list")
            counter="${#SELECTEDCODES[@]}"
            
            for downloadVideoUrl in "${SELECTEDCODES[@]}"; do
                
                clear
                __
                youtube-dl -F "${ytdlPreset_DW[@]}" "$downloadVideoUrl" \
                | awk '$0 !~ /sb|youtube/{print $0}'
                __
                printf '%s\n' " ${critical}If you pick a format from a none m3u8 protocol, download will fail " \
                " if ffmpeg is set as downloader in your configuration file." \
                " ${info}Choose a format code for: $(_GetLinkTitle -l)" \
                " eg: 137+251 for merging, hls-1080p, 22 for single:${nc}"
                
                read -r code
                clear
                __
                printf '%s\n' " ${info}$counter file(s) left to download." \
                " Downloading $(_GetLinkTitle -l).${nc}"
                
                if [[ "$code" =~ '+' && $(_GetLinkTitle -l) =~ '/' ]]; then
                    youtube-dl "${ytdlPreset_FS[@]}" \
                    --format "$code" \
                    "${ytdlPreset_X[@]}" "$downloadVideoUrl"
                elif [[ "$code" =~ '+' ]]; then
                    youtube-dl --format "$code" \
                    --output "$(_GetLinkTitle -l).%(ext)s" \
                    "${ytdlPreset_X[@]}" "$downloadVideoUrl"
                else
                    youtube-dl --format "$code" \
                    --output "$(_GetLinkTitle -l).%(ext)s" \
                    "${ytdlPreset_NC[@]}" "$downloadVideoUrl"
                fi

                sed -i '2d' "$playlists_dir"/"$list"
                sed -i '1d' "$titles_dir"/"$list".titles
                ((counter--))
                clear

            done
        ;;
    esac

    echo " ${info}All done${nc}"
    sleep 2
    _DownloadCompleted

}

_EditPlaylist() {
    while true; do
        clear
        cd "$playlists_dir" || exit 1
        __
        PS3=""$'\n'" ${info}Choose a playlist to edit: ${nc}"

        select list in $(find . -not -name "default.m3u" -name "*.m3u" \
            -o -name "*.m3u_origin" | sort -d | sed 's,.*/,,'); do
            __
            read -rsn 1 -p \
            "${info}"' [E]dit urls manually, [R]emove titles.'"${nc}" edit
            if [[ $edit =~ e|E ]]; then
                $MPMEDITOR "$list"
                echo -e " ${info}$list saved${nc}\n"
                [[ $(grep "" -c "$titles_dir/$list.titles") \
                -ne $(_GetLinesList -l) ]] && _TitlesListCompare
            elif [[ $edit =~ r|R ]]; then
                clear
                _TitlesListCompare -l
                _GetRange
                unset IFS
                _UpdateSelected -e
            else
                __
                printf '%s\n' " ${critical}Wrong option $edit...${nc}"
                sleep 3
            fi
            __
            read -rsn 1 \
            -p "${info}"' [C]ontinue editing, [B]ack to menu or [Q]uit.'"${nc}" again
            case "$again" in
                c|C)
                    break
                ;;
                b|B)
                    _Menu
                ;;
                q|Q)
                    __;__
                    if [[ -s "$AUDIO_URLS" || -s "$VIDEO_URLS" ]]; then
                        _SaveOnExit
                    else
                        nc=$'\e[0m';
                        echo "${nc}"
                        clear
                        exit 0
                    fi
                ;;
                *)
                    printf '%s\n' " ${critical}Wrong option $again...${nc}"
                    sleep 3
                ;;
            esac
        done
    done
}

_EditMpmConf() {

    $MPMEDITOR "$MPMRC"
    printf '%s\n' " ${info}mpm config saved! New changes actives.${nc}"
    . "$MPMRC"
    _Theme "$THEME"
    sleep 3
    clear
    _Menu

}

_GetCompleted() {

    cd "$main_dir" || exit 1

    if [[ -n $(find {"$audios_dir","$videos_dir"} -name "*.part") ]]; then
        _IfPartsExist -t
    else
        _Prompt -n " ${info}Downloads completed, KEEP playlist?: ${nc}" && {
            __
            echo " ${critical}If it was a temporary list, don't forget to save it.${nc}"
            sleep 4
            _RenameTmpFiles
            rm -rf "$HOME"/.parallel 2>/dev/null
            _Menu
        }

        case "$1" in
            -a)
                if [[ -f "$QUEUE"_origin ]]; then
                    _Remove -q
                else
                    _Remove -a
                fi
            ;;
            -v)
                if [[ -f "$QUEUE"_origin ]]; then
                    _Remove -q
                else
                    _Remove -v
                fi
            ;;
        esac
    fi

}

_DirectVideoDownload() {

    cd "$playlists_dir" || exit 1
    local counter
    __
    printf '%s\n' " ${task}Direct download enabled.${nc}"
    __
    cp -f "$list" "$list"_origin
    mkdir --parents "$videos_dir"/"${list%.*}" \
    && cd "$videos_dir"/"${list%.*}"

    mapfile -t DIRECT < <(grep '^https' "$playlists_dir"/"$list")
    counter="${#DIRECT[@]}"
    
    for line in "${DIRECT[@]}"; do

        printf '%s\n' " ${info}$counter file(s) left to download." \
        " Downloading: $(_GetLinkTitle -l)${nc}"
        
        if [[ $line =~ 'youtube.com' && $(_GetLinkTitle -l) =~ '/' ]]; then
            youtube-dl "${ytdlPreset_FS[@]}" \
            "${ytdlPreset_X[@]}" "$line"
        elif [[ $line =~ 'youtube.com' ]]; then
            youtube-dl \
            --output "$(_GetLinkTitle -l).%(ext)s" \
            "${ytdlPreset_X[@]}" "$line"
        else
            youtube-dl \
            --output "$(_GetLinkTitle -l).%(ext)s" \
            "${ytdlPreset_NC[@]}" "$line"
        fi

        ((counter--))

        sed -i '2d' "$playlists_dir"/"$list"
        sed -i '1d' "$titles_dir"/"$list".titles
        clear

    done

}

_GetVideoDownload() {

    cd "$videos_dir" || exit 1

    mapfile -t VIDEOLINKS < <(grep '^https' "$M3UFILE")
    
    for getVideoUrl in "${VIDEOLINKS[@]}"; do
        __
        youtube-dl -F "${ytdlPreset_DW[@]}" "$getVideoUrl" \
        | awk '$0 !~ /sb|youtube/{print $0}'
        __
        __ChooseFormatMessages
        read -r code
        clear
        __
        __DownloadMessages

        # it seems that only youtube uses merging options
        if [[ "$code" =~ '+' ]]; then
            # downloader presets described in ~/.config/mpm/mpmrc
            # we have to differenciate titles files because of _GetLinkTitle function.
            if [[ $(sed -n '1p' "$TITLES") =~ '/' ]]; then
                youtube-dl --format "$code" "${ytdlPreset_FS[@]}" \
                "${ytdlPreset_X[@]}" "$getVideoUrl"
            else
                youtube-dl --format "$code" \
                --output "$(sed -n '1p' "$TITLES").%(ext)s" \
                "${ytdlPreset_X[@]}" "$getVideoUrl"
            fi
            
        else
        
            if [[ $(sed -n '1p' "$TITLES") =~ '/' ]]; then
                youtube-dl --format "$code" "${ytdlPreset_FS[@]}" \
                "${ytdlPreset_NC[@]}" "$getVideoUrl"
            else
                youtube-dl --format "$code" \
                --output "$(sed -n '1p' "$TITLES").%(ext)s" \
                "${ytdlPreset_NC[@]}" "$getVideoUrl"
            fi
            
        fi

        if [[ $M3UFILE = "$VIDEO_URLS" ]]; then
            sed -i '1d' {"$M3UFILE","$TITLES"}
            clear
        else
            sed -i '2d' "$M3UFILE"
            sed -i '1d' "$TITLES"
            clear
        fi

    done

}

_GetVideo() {

    local M3UFILE TITLES

    case "$1" in
        -q)
            __
            if [[ ! -f $DEFAULTITLES && \
                -f $DEFAULTM3UTITLES ]]; then
                cat "$DEFAULTM3UTITLES" > \
                "$DEFAULTITLES"
            elif [[ -f $DEFAULTITLES ]]; then
                printf '%s\n' " ${info}Fetching titles file...${nc}"
                sleep 1
            else
                printf '%s\n' " ${info}Getting titles...${nc}"
                _GetMediaTitle -q > "$DEFAULTITLES"
                clear
            fi
            M3UFILE="$QUEUE"
            TITLES="$DEFAULTITLES"
        ;;
        -v)
            __
            [[ $(_GetLinesList -v) -eq 0 ]] && {
                echo " ${critical}No links in the $Type list${nc}"
                sleep 2
                return
            }
            M3UFILE="$VIDEO_URLS"
            TITLES="$VIDEO_TITLES"
        ;;
    esac

    cp -f "$M3UFILE" "$M3UFILE"_origin
    cp -f "$TITLES" "$TITLES"_origin
    clear

    __ChooseFormatMessages() (
        printf '%s\n' " ${critical}If you pick a format from a none m3u8 protocol, download will fail " \
        " if ffmpeg is set as downloader in your configuration file." \
        " ${info}Choose a format code for: $(sed -n '1p' "$TITLES")." \
        " eg: 137+251 (video+audio), hls-1080p, 22 for single:${nc}"
    )

    __DownloadMessages() (
        [[ $TITLES = "$DEFAULTITLES" ]] && {
            printf '%s\n' " ${info}$(_GetLinesList -q) video file(s) left to download." \
            " Downloading:  $(sed -n '1p' "$TITLES")${nc}"
        }
        [[ $TITLES = "$VIDEO_TITLES" ]] && {
            printf '%s\n' " ${info}$(_GetLinesList -v) video file(s) left to download." \
            " Downloading:  $(sed -n '1p' "$TITLES")${nc}"
        }
    )

    cd "$videos_dir" || exit 1

    _GetVideoDownload && {
        echo -e " ${info}Done.\n${nc}"
        sleep 2
        _GetCompleted -v
    }
}

_LoadAudioVideoTmp() {

    declare -a TMP=( "$AUDIO_URLS" "$AUDIO_TITLES" "$VIDEO_URLS" \
                    "$VIDEO_TITLES" "$CHOOSE1" "$FFOP" "$YTOP" )
    
    __LoadAudioVideoTmpNotice() (
        clear
        __
        _Prompt " ${info}$tmpFile list still exist, KEEP it?:${nc}" || {
            rm -f "${TMP[@]}" 2>/dev/null
            echo " ${critical}$tmpFile list removed...${nc}"
            sleep 3
        }
    )

    case "$1" in
        -a)
            if [[ -s ${TMP[0]} ]]; then
                if [[ -n $(pidof mpv) && -f $CHOOSE1 ]]; then
                    unset {TMP[2],TMP[3],TMP[4]}
                else
                    unset {TMP[2],TMP[3]}
                fi
                tmpFile=Audio
                __LoadAudioVideoTmpNotice
            fi
            return
        ;;
        # -c)
        #     unset {TMP[0],TMP[1],TMP[2],TMP[3]}
        #     rm "${TMP[@]}" 2>/dev/null
        # ;;
        -v)
            if [[ -s ${TMP[2]} ]]; then
                if [[ -n $(pidof mpv) && -f $CHOOSE1 ]]; then
                    unset {TMP[0],TMP[1],TMP[4]}
                else
                    unset {TMP[0],TMP[1]}
                fi

                tmpFile=Video
                __LoadAudioVideoTmpNotice
            fi
            return
        ;;
    esac
    
    [[ $quit_after_task = yes ]] && exit || _Menu

}

_LoadAudioVideo() {

    local m3uFile use_mpvc_online
    use_mpvc_online="yes"

    __LoadAudioVideoAdvice() (
        clear
        __
        printf '%s\n' " ${critical}Tip: You may want to put this in your mpv.conf:" \
        " ${info}term-playing-msg='Tiltle: \${media-title}'"
        echo -e " ${critical}Otherwise press I in mpv for more infos.${nc}\n"
        file="${m3uFile##*/}" file="${file%%.*}"
        printf '%s\n' " ${info}Playing: ${file} playlist.${nc}"
        __
    )
    
    # change mpv settings in ~/.config/mpm/mpmrc
    __mpvOnlineAudioCommand() (
        if [[ $use_mpvc = yes ]]; then
            mpv \
            --no-terminal \
            "${mpvGenOptions_X[@]}" \
            "${mpvAudioFormatOptions[@]}" "$1" &
            echo "$m3uFile" > "$NOWPLAYING"
        else
            __LoadAudioVideoAdvice
            mpv \
            "${mpvGenOptions_X[@]}" \
            "${mpvAudioFormatOptions[@]}" "$1"
            _LoadAudioVideoTmp -a
        fi
    )

    __mpvOnlineVideoCommand() (
        if [[ $use_mpvc = yes ]]; then
            mpv \
            --no-terminal \
            "${mpvGenOptions_X[@]}" \
            "${mpvVideoOptions_X[@]}" \
            "${mpvVideoFormatOptions[@]}" "$1" &
            echo "$m3uFile" > "$NOWPLAYING"
        else
            __LoadAudioVideoAdvice
            mpv \
            "${mpvGenOptions_X[@]}" \
            "${mpvVideoOptions_X[@]}" \
            "${mpvVideoFormatOptions[@]}" "$1"
            _LoadAudioVideoTmp -v
        fi
    )

    __killMpvPid() (
        while pidof mpv >/dev/null; do
            kill -SIGTERM "$(pidof mpv)"
            rm "$NOWPLAYING"
            sleep 0.5
        done
    )

    case "$1" in
        -a)
            if [[ -s $AUDIO_URLS ]]; then
                m3uFile="$AUDIO_URLS"
                __killMpvPid
                __mpvOnlineAudioCommand "$m3uFile"
            else
                echo " ${critical}No links in the $Type list${nc}"
                sleep 2 && return
            fi
        ;;
        -ca)
            m3uFile="$CHOOSE1"
            __killMpvPid
            __mpvOnlineAudioCommand "$m3uFile"
        ;;
        -cv)
            m3uFile="$CHOOSE1"
            __killMpvPid
            __mpvOnlineVideoCommand "$m3uFile"
        ;;
        -la)
            m3uFile="$playlists_dir/$list"
            __killMpvPid
            __mpvOnlineAudioCommand "$m3uFile"
        ;;
        -lv)
            m3uFile="$playlists_dir/$list"
            __killMpvPid
            __mpvOnlineVideoCommand "$m3uFile"
        ;;
        -qa)
            m3uFile="$QUEUE"
            __killMpvPid
            __mpvOnlineAudioCommand "$m3uFile"
        ;;
        -qv)
            m3uFile="$QUEUE"
            __killMpvPid
            __mpvOnlineVideoCommand "$m3uFile"
        ;;
        -v)
            if [[ -s $VIDEO_URLS ]]; then
                m3uFile="$VIDEO_URLS"
                __killMpvPid
                __mpvOnlineVideoCommand "$m3uFile"
            else
                echo " ${critical}No links in the $Type list${nc}"
                sleep 2 && return
            fi
        ;;
    esac
    
    _Menu
}

_TitlesListCompare() {

    cd "$titles_dir" || return

    local titles
    titles="$titles_dir/$list.titles"
    titles="${titles##*/}"

    # first test if "myplaylist".titles exist.
    if [[ -s $titles ]]; then

        if [[ $(grep "" -c "$titles") -ne $(_GetLinesList -l) ]]; then
            __
            printf '%s\n' " ${critical}${titles} is out of date...${nc}" \
            " ${task}${b}Updating titles...please wait.${nb}${nc}"
            _GetMediaTitle -l > "$titles_dir"/"$list".titles
            clear
        fi

        case "$1" in
            -g)
                echo -e " ${info}Titles for $list.${nc}\n"
                sed -n '1,25p' "$titles" | cat -n
                # awk 'NR>=1&&NR<=25' "$titles" | cat -n
                __
                read -rsn 1 -p " ${info}Press 'n' for next page${nc} " nextpage
                case "$nextpage" in
                    n|N)
                        clear; __
                        sed -n '26,$p' "$titles" | cat -n
                        __
                    ;;
                    *)
                        __
                        printf '%s\n' " ${critical}Wrong option $nextpage...${nc}"
                        sleep 3s
                        _Menu
                    ;;
                esac
            ;;
            -l)
                __
                echo -e " ${info}Titles for $list.${nc}\n"
                cat -n "$titles"
                __
            ;;
        esac
        
    else
        printf '%s\n' " ${critical}${titles} does not exist...${nc}" \
        " ${task}${b}Getting titles...please wait.${nb}${nc}"
        _GetMediaTitle -l > "$titles_dir"/"$list".titles
        clear
        __
        echo -e " ${info}Titles for $list.${nc}\n"
        cat -n "$titles"
        __

    fi

}

_ChooseFromPlay() {
    cd "$playlists_dir" || exit 1
    clear
    _TitlesListCompare -l

    [[ -f $CHOOSE1 ]] && rm "$CHOOSE1"

    read -rsn 1 \
    -p "${info}"" [B]ack to menu, Play all items as [A]udio, [V]ideo or ${b}[S]elect:${nb} ""${nc}" choice
    
    case "$choice" in
        a|A)
            _LoadAudioVideo -la
        ;;
        b|B)
            _Menu 
        ;;
        v|V)
            _LoadAudioVideo -lv
        ;;
        s|S)
            __
            _GetRange
            rm "$SELECTEDTITLES"
            unset IFS
            __
            read -rsn 1 -p "${info}"' load [A]udio, [V]ideo: '"${nc}" load
            case "$load" in
                a|A)
                    _LoadAudioVideo -ca
                ;;
                v|V)
                    clear
                    _LoadAudioVideo -cv
                ;;
                *)
                    __
                    printf '%s\n' " ${critical}Wrong option $load...${nc}"
                    sleep 3s
                    _LoadPlaylistMenu
                ;;
            esac
        ;;
        *)
            __
            printf '%s\n' " ${critical}Wrong option $choice...${nc}"
            sleep 3s
            _LoadPlaylistMenu
        ;;
    esac
    _Menu
}

_UpdateSelected() {
    cd "$playlists_dir" || exit 1
    
    # let's remove downloaded links from the original file
    # and sending the other ones in a second temporary file...
    grep -v "$(grep '^https' "$CHOOSE1")" "$list" >> "$CHOOSE2"
    perl -i -ne 'print if ! $a{$_}++' "$CHOOSE2"
    
    # ...that we now rename with the original file name.
    mv -f "$CHOOSE2" "$list"
    rm "$CHOOSE1"
    cd "$titles_dir" || exit 1

    case "$1" in
        -e)
            grep -v "$(grep '^[[:print:]]' "$SELECTEDTITLES")" \
            "$titles_dir"/"$list".titles >> "$SELECTEDTITLES"_tmp
            perl -i -ne 'print if ! $a{$_}++' "$SELECTEDTITLES"_tmp
            mv -f "$SELECTEDTITLES"_tmp "$titles_dir"/"$list".titles
            rm "$SELECTEDTITLES"
            __
            printf '%s\n' " ${info}Changes applied in $list.${nc}"
            sleep 3
        ;;
        -u)
            grep -v "$(grep '^[[:print:]]' "$SELECTEDTITLES"_orgin)" \
            "$titles_dir"/"$list".titles >> "$SELECTEDTITLES"
            perl -i -ne 'print if ! $a{$_}++' "$SELECTEDTITLES"
            mv -f "$SELECTEDTITLES" "$titles_dir"/"$list".titles
            rm "$SELECTEDTITLES"_orgin
        ;;
    esac
    
    clear
}

_ChooseDownloadAudio() {

    local counter M3UFILE
    cd "$playlists_dir" || exit 1
    clear
    _TitlesListCompare -l
    _GetRange

    clear
    cp -f "$list" "$list"_origin
    cp -f "$SELECTEDTITLES" "$SELECTEDTITLES"_orgin
    mkdir --parents "$audios_dir"/"${list%.*}" \
    && cd "$audios_dir"/"${list%.*}"

    M3UFILE="$CHOOSE1"
    readarray -t SELECTEDAUDIO < "$M3UFILE"
    counter="${#SELECTEDAUDIO[@]}"
    
    __ChooseDownloadAudioMessage() (
        printf '%s\n' " ${info}$counter file(s) left to downloads." \
        " Downloading: $(_GetLinkTitle -s)${nc}"
    )
    
    for url in "${SELECTEDAUDIO[@]}"; do

        if [[ $direct_download = yes ]] && \
            [[ $(youtube-dl -F "${ytdlPreset_DW[@]}" "$url" \
            | grep '^251') ]]; then

            printf '%s\n' " ${task}Direct download enabled.${nc}"
            __
            __ChooseDownloadAudioMessage
            youtube-dl --output "$(_GetLinkTitle -s).%(ext)s" \
            --format 251 "${ytdlPreset_NC[@]}" "$url"

        elif [[ $direct_download = no ]] && [[ $url =~ 'youtube.com' ]]; then
            __
            printf '%s\n' " ${task}Direct download disabled.${nc}"
            __
            youtube-dl -F "${ytdlPreset_DW[@]}" "$url" \
            | awk '/audio only|PROTO|^[-]/ {sub("^[sb*]",""); print $0}'
            __
            printf '%s\n' " ${info}Choose a format code for: $(_GetLinkTitle -s)${nc}"
            read -r code
            clear
            __
            __ChooseDownloadAudioMessage
            
            youtube-dl --output "$(_GetLinkTitle -s).%(ext)s" \
            --format "$code" "${ytdlPreset_NC[@]}" "$url"

        else

            youtube-dl -F "${ytdlPreset_DW[@]}" "$url"
            printf '%s\n' " ${info}Choose a format code for: $(_GetLinkTitle -s)${nc}"
            read -r code
            clear
            __
            __ChooseDownloadAudioMessage
            youtube-dl --output "$(_GetLinkTitle -s).%(ext)s" \
            --format "$code" "${ytdlPreset_NC[@]}" "$url"

        fi

        sed -i '1d' "$SELECTEDTITLES"
        ((counter--))
        clear

    done

    _UpdateSelected -u
    # if we don't unset IFS other functions will be messed up!
    unset IFS
    clear
    echo -e " ${info}Done${nc}\n"
    clear
    _IfWebmFiles
}

_ChooseDirectVideoDownload() {

    local counter
    clear
    cd "$playlists_dir" || exit 1
    _TitlesListCompare -l
    _GetRange
    
    clear
    cp -f "$list" "$list"_origin
    cp -f "$SELECTEDTITLES" "$SELECTEDTITLES"_orgin
    mkdir --parents "$videos_dir"/"${list%.*}" \
    && cd "$videos_dir"/"${list%.*}"
    
    readarray -t DIRECT < "$CHOOSE1"
    counter="${#DIRECT[@]}"
    
    for line in "${DIRECT[@]}"; do

        if [[ $direct_download = yes ]]; then
            printf '%s\n' " ${task}Direct download enabled.${nc}"
        else
            printf '%s\n' " ${task}Download method = direct.${nc}"
        fi
        __
        printf '%s\n' " ${info}$counter file(s) left to downloads." \
        " Downloading: $(_GetLinkTitle -s)${nc}"

        if [[ $line =~ 'youtube.com' && $(_GetLinkTitle -s) =~ '/' ]]; then
            # downloader presets described in ~/.config/mpm/mpmrc
            youtube-dl "${ytdlPreset_FS[@]}" \
            "${ytdlPreset_X[@]}" "$line"
        elif [[ $line =~ 'youtube.com' ]]; then
            youtube-dl \
            --output "$(_GetLinkTitle -s).%(ext)s" \
            "${ytdlPreset_X[@]}" "$line"
        else
            youtube-dl \
            --output "$(_GetLinkTitle -s).%(ext)s" \
            "${ytdlPreset_NC[@]}" "$line"
        fi

        sed -i '1d' "$SELECTEDTITLES"
        ((counter--))
        clear
    done

    unset IFS
    echo " ${info}All done${nc}"
    sleep 2

}

_ChooseDownloadVideo() {

    local counter
    cd "$playlists_dir" || exit 1
    clear

    if [[ $direct_download = yes ]]; then
        _ChooseDirectVideoDownload
    else
        __
        printf '%s\n' " ${task}Direct download disabled."
        __
        printf '%s\n' " ${critical}Tip: direct download will always pick the best format," \
        " on Youtube webm may be the best one but we'll merge files in mp4."
        echo -e " ${info}[B]ack to download options, choose [S]pecific codes or [D]irect download?:\n${nc}"
        read -rsn 1 choice
    fi

    case "$choice" in
        b|B) clear; return ;;
        d|D) _ChooseDirectVideoDownload ;;
        s|S)
            _TitlesListCompare -l
            _GetRange
            clear
            
            cp -f "$list" "$list"_origin
            cp -f "$SELECTEDTITLES" "$SELECTEDTITLES"_orgin
            mkdir --parents "$videos_dir"/"${list%.*}" \
            && cd "$videos_dir"/"${list%.*}"
            
            readarray -t CHOSENCODES < "$CHOOSE1"
            counter="${#CHOSENCODES[@]}"
            
            for url in "${CHOSENCODES[@]}"; do

                if [[ $url =~ 'youtube.com' ]]; then
                    __
                    youtube-dl -F "${ytdlPreset_DW[@]}" "$url" \
                    | awk '$0 !~ /sb|youtube/{print $0}'
                else
                    youtube-dl -F "${ytdlPreset_DW[@]}" "$url"
                fi
                __
                printf '%s\n' " ${critical}If you pick a format from a none m3u8 protocol, download will fail " \
                " if ffmpeg is set as downloader in your configuration file." \
                " ${info}Choose a format code for: $(_GetLinkTitle -s)" \
                " eg: 137+251 for merging, hls-1080p, 22 for single:${nc}"
                
                read -r code
                sleep 0.5
                clear
                printf '%s\n' " ${info}$counter file(s) left to downloads." \
                " Downloading: $(_GetLinkTitle -s)${nc}"
                
                if [[ $line =~ 'youtube.com' && $(_GetLinkTitle -s) =~ '/' ]]; then
                    # downloader presets described in ~/.config/mpm/mpmrc
                    youtube-dl "${ytdlPreset_FS[@]}" \
                    --format "$code" "${ytdlPreset_X[@]}" "$line"
                elif [[ $line =~ 'youtube.com' ]]; then
                    youtube-dl \
                    --output "$(_GetLinkTitle -s).%(ext)s" \
                    --format "$code" "${ytdlPreset_X[@]}" "$line"
                else
                    youtube-dl \
                    --output "$(_GetLinkTitle -s).%(ext)s" \
                    --format "$code" "${ytdlPreset_NC[@]}" "$line"
                fi

                sed -i '1d' "$SELECTEDTITLES"
                ((counter--))
                clear

            done

            echo " ${info}All done${nc}"
            sleep 2
        ;;
    esac

    _UpdateSelected -u
    unset IFS
    clear
    _DownloadCompleted

}

_LoadPlaylistMenu() {

    cd "$playlists_dir" || return
    while :; do
        _ResizeWindow
        clear
        [[ $direct_download = yes ]] && {
            __
            printf '%s\n' " ${task}Direct download enabled.${nc}"
        }
        __
        echo " ${info}$list: $(grep -c '^https' "$list") url(s).${nc}"
        __
        echo -e "                                                ${mtitle}::DOWNLOAD/PLAY OPTIONS::${nc}"
        echo -e "                                  ┌───────────────────────────────────────────────────┐"
        echo -e "                                  │     1) Choose playlist titles & download ${info}audio${nc}    │"
        echo -e "                                  │     2) Choose playlist titles & download ${info}video${nc}    │"
        echo -e "                                  │     3) Download whole playlist as ${info}audio${nc} files     │"
        echo -e "                                  │     4) Download whole playlist as ${info}video${nc} files     │"
        echo -e "                                  │     5) Choose playlist links & play ${info}audio/video${nc}   │"
        echo -e "                                  │     6) Back to main menu                          │"
        echo -e "                                  └───────────────────────────────────────────────────┘"
        echo -e "                                                    ${info}${b}Select an item${nb}${nc}"
        __
        read -rsn 1 loadPlaylistMenuOptions
        case "$loadPlaylistMenuOptions" in
            1)
                _ChooseDownloadAudio
            ;;
            2)
                _ChooseDownloadVideo
            ;;
            3)
                _GetAudio -l
            ;;
            4)
                _DownloadVideoList
            ;;
            5)
                _ChooseFromPlay
            ;;
            6)
                _Menu
            ;;
            *)
                __
                printf '%s\n' " ${critical}Wrong option $loadPlaylistMenuOptions...${nc}"
                sleep 3s && continue
            ;;
        esac
    done

}

_LoadPlaylist() {
    
    cd "$playlists_dir" || exit 1

    local list

    [[ -z $(find . -type f -name "*.m3u") ]] && {
        clear; __
        printf '%s\n' " ${critical}No playlist found!${nc}" \
        " ${task}First make a temporary list using options 1 or 2," \
        " save it as wathever you like, then come back to play/download it.${nc}"
        sleep 8 && return

    }

    for dotM3uFile in $(find . -type f -name "*.m3u"); do
        [[ -f "$dotM3uFile"_origin ]] \
        && mv "$dotM3uFile"_origin "$dotM3uFile"
    done

    clear
    touch 1_Back_to_menu
    __

    PS3=""$'\n'"${info}Select a playlist to load or hit 1) for main menu:${nc} "
    select list in $(find . -type f -not -name "default.m3u" \
        | sort -d | sed 's,.*/,,'); do

        [[ $list = 1_Back_to_menu ]] && rm 1_Back_to_menu && break

        [[ $(_GetLinesList -l) -eq 0 ]] && {
            echo " ${critical}No links found in $list (empty or does not contains #EXTM3U header)."
            echo " You can edit and fix it in option 8) Edit a playlist.${nc}"
            sleep 8
            return
        }

        rm 1_Back_to_menu
        clear
        __
        printf '%s\n' " ${info}Choose an option for${nc} $list ($(grep -v '#EXTM3U' -c "$list") urls)."
        __
        read -rn 1 -p "${info}"' [1] Download/Play, [2] View titles: '"${nc}" submenu
        __
        case "$submenu" in
            1)
                clear; _LoadPlaylistMenu
            ;;
            2)
                clear

                if (( $(grep "" -c "$titles_dir/$list.titles") > 25 )); then
                    _TitlesListCompare -g
                else
                    _TitlesListCompare -l
                fi

                read -rn 1 \
                -p "${info}"' [1] Download/Play, [2] Back to menu: '"${nc}" loadPlaylistOptions
                __
                case "$loadPlaylistOptions" in
                    1) clear; _LoadPlaylistMenu ;;
                    2) break ;;
                    *)
                        __
                        printf '%s\n' " ${critical}Wrong option $loadPlaylistOptions...${nc}"
                        sleep 3
                        return
                    ;;
                esac
            ;;
            *)
                __
                printf '%s\n' " ${critical}Wrong option $submenu...${nc}"
                sleep 3
                return
            ;;
        esac

    done
}

_ReplaceSpaces() {
    # the select loop will not parse correctly
    # if we don't replace spaces with underscores
    case "$1" in
        -l)
            find "$MEDIA_DIR" -maxdepth 1 \
            -type d -name "* *" -exec \
            bash -c '
                for d in "$@"; do
                    n="${d##*/}"
                    mv -nv "$d" "${d%/*}/${n// /_}"
                done >/dev/null 2>&1
            ' dummy {} +
        ;;
        -s)
            find {"$playlists_dir","$titles_dir"} -maxdepth 1 \
            -type f -name "* *" -exec \
            bash -c '
                for f in "$@"; do
                    n="${f##*/}"
                    mv -nv "$f" "${f%/*}/${n// /_}"
                done >/dev/null 2>&1
            ' dummy {} +
        ;;
    esac

}

_LoadLocal() {

    local AUDIOS VIDEOS MEDIA_DIR use_mpvc_locally
    # we use -maxdepth 2 in case our directories are in subdirectories.
    AUDIOS=$(find "$HOME" -maxdepth 2 -type d -wholename "$MUSIC_DIR")
    VIDEOS=$(find "$HOME" -maxdepth 2 -type d -wholename "$VIDEO_DIR")
    use_mpvc_locally="yes"
    
    __mpvDirCommand() (
        cd "$MEDIA_DIR"/"$dir" || return
        if [[ $use_mpvc = yes ]]; then
            __
            find . -type f | sort | sed 's,.*/,,' \
            | mpv --no-terminal "${mpvGenOptions_X[@]}" --playlist=- &
            _Menu
        else
            __
            find . -type f | sort | sed 's,.*/,,' \
            | mpv "${mpvGenOptions_X[@]}" --playlist=-
        fi
        
    )

    __selectDir() (
        echo -e " ${info}Directories in $MEDIA_DIR: ${nc}\n"
        PS3=""$'\n'"${info}Your selection number: ${nc}"
        select dir in $(find -L "$MEDIA_DIR" -maxdepth 1 -type d -not -name \
            "$(echo "$MEDIA_DIR" | awk -F"/" '{print $NF}')" | sort | sed 's,.*/,,'); do

            if [[ $(find "$MEDIA_DIR"/"$dir" -type d -empty) ]]; then
                __
                printf '%s\n' " ${critical}$dir is empty. Wait and try again...${nc}"
                sleep 4
                continue
            else
                # checking for content in symlinked directories.
                command ls "$MEDIA_DIR"/"$dir" >/dev/null || {
                    __
                    printf '%s\n' " ${critical}This symlink points to an empty" \
                    " or none existing directory, wait and try again...${nc}"
                    sleep 4
                    continue
                }
                clear
                __mpvDirCommand
                break
            fi

        done
    )

    read -rsn 1 \
    -p " ${info}Play: [1] Audio dir, [2] Audio files, [3] Video dir or [4] Video files?: ${nc}"

    case "$REPLY" in
        1)
            MEDIA_DIR="$AUDIOS"
            _ReplaceSpaces -l
            clear
            __
            __selectDir
        ;;
        2)
            clear; "$FILEMANAGER" "$AUDIOS"; _Menu
        ;;
        3)
            MEDIA_DIR="$VIDEOS"
            _ReplaceSpaces -l
            clear
            __
            __selectDir
        ;;
        4)
            clear; "$FILEMANAGER" "$VIDEOS"; _Menu
        ;;
        *)
            printf '%s\n' " ${critical}Wrong option $choice!${nc}"
            sleep 3
            return
        ;;
    esac

}

_SaveList() {
    cd "$playlists_dir" || exit 1
    cp -f "$CURRENT_LIST" "$list"
    cp -f "$CURRENT_TITLES" "$titles_dir"/"$list".titles 2>/dev/null

    sed -i '1s/^/#EXTM3U\n/' "$list"
    sed -i '/^[[:alpha:]]/d' "$CURRENT_LIST"

    (( $(grep -c -w '#EXTM3U' "$list") > 1 )) \
        && sed -i '1d' "$list"

    if [[ $CURRENT_LIST = "$QUEUE" ]]; then
        __
        printf '%s\n' " ${info}default list saved as $list${nc}"
    else
        rm {"$CURRENT_LIST","$CURRENT_TITLES"}
        __
        printf '%s\n' " ${info}${CURRENT_LIST##*/} saved as $list${nc}"
    fi
    _mpmIpc
    sleep 3
}

_SaveCheck() {
    clear
    cd "$playlists_dir" || exit 1

    local listTotal
    listTotal=$(find . -not -name "default.m3u" -name "*.m3u" \
    -o -name "*.m3u_origin" | wc -l)

    __listAlreadyExists() (
        __
        read -rp "${info}"' Enter the new playlist name (do not use extension): '"${nc}" list
        list="$list.m3u"
        [[ -f $list ]] && {
            __
            _Prompt -n " ${critical}$list ALREADY exists! Overwrite it?: ${nc}" && {
                _SaveList
            }
            _Menu
        }
        _SaveList
    )
    __
    printf '%s\n' " ${critical}Tip: If you want to add links to an existing playlist," \
    " just select it and answer NO to the overwrite question," \
    " you can now add your links by entering 'a'${nc}"
    __
    PS3=""$'\n'" ${info}Available playlists (type ${task}$((listTotal + 1)) ${info}to create a new one):${nc} "
    select list in $(find . -not -name "default.m3u" -name "*.m3u" \
        -o -name "*.m3u_origin" | sort -d | sed 's,.*/,,'); do
        
        [[ $REPLY != $((listTotal + 1)) ]] && {

            if [[ $(find . -name "${list}") ]]; then
                __
                _Prompt -n " ${critical}$list already exists! Overwrite it?: ${nc}" && {
                    _SaveList && break
                }
                __
                read -rp " ${info}[S]ave playlist as a new one or [A]dd links to $list?: ${nc}" saveOrAddLinks
                case "$saveOrAddLinks" in
                    a|A)
                        cat "$CURRENT_LIST" >> "$list"
                        cat "$CURRENT_TITLES" >> "$titles_dir/$list.titles"
                        perl -i -ne 'print if ! $a{$_}++' {"$list","$titles_dir/$list.titles"}
                        __
                        printf '%s\n' " ${info}Link(s) added to $list.${nc}"

                        rm {"$CURRENT_LIST","$CURRENT_TITLES"}
                        [[ $CURRENT_LIST = "$QUEUE" ]] && echo "#EXTM3U" > "$QUEUE"
                        sleep 2
                        break
                    ;;
                    s|S)
                        __listAlreadyExists && break
                    ;;
                    *)
                        printf '%s\n' " ${critical}Wrong option $saveOrAddLinks, try again later...${nc}"
                        sleep 4
                        break
                    ;;
                esac
                
            else
                __
                printf '%s\n' " ${critical}Wrong entry $REPLY, try again later...${nc}"
                sleep 4
                break
            fi

        }

        __listAlreadyExists && break

    done
}

_Save() {

    local CURRENT_LIST CURRENT_TITLES
    
    cd "$playlists_dir" || exit 1

    case "$1" in
        -a)
            if [[ -f $AUDIO_URLS ]]; then
                CURRENT_LIST="$AUDIO_URLS"
                CURRENT_TITLES="$AUDIO_TITLES"
                _SaveCheck
                _ReplaceSpaces -s
            else
                printf '%s\n' " ${critical}No links in the $Type list${nc}"
                sleep 2
                return
            fi
        ;;
        -q)
            CURRENT_LIST="$QUEUE"
            if [[ -f $DEFAULTITLES ]]; then
                CURRENT_TITLES="$DEFAULTITLES"
            else
                CURRENT_TITLES="$DEFAULTM3UTITLES"
            fi
            _SaveCheck
            _ReplaceSpaces -s
        ;;
        -v)
            if [[ -f $VIDEO_URLS ]]; then
                CURRENT_LIST="$VIDEO_URLS"
                CURRENT_TITLES="$VIDEO_TITLES"
                _SaveCheck
                _ReplaceSpaces -s
            else
                printf '%s\n' " ${critical}No links in the $Type list${nc}"
                sleep 2
                return
            fi
        ;;
    esac
    _Menu
}

_Remove() {

    cd "$tmp_dir" || exit 1

    __removeTmpLinks() (
        clear
        __
        cat -n "$tmpTitles"
        RP=$(printf '%s\n' "Enter numbers separeted by commas or a dash for a range" \
        " for example: ${task}1-4,6 8-11 or 1-4,6-8,10 or 2,3,5,6,1 : ${nc}")
        __
        IFS=", "; read -ra array -p " ${info}""$RP""${nc}"

        for range in "${array[@]}"; do
            IFS="-"; read -r start end <<< "$range"
            [[ -z $start ]] && continue
            [[ -z $end ]] && end="$start"
            for ((i=start;i <= end;i++)); do
                sed -n "${i}p" "$tmpList" >> "$tmpList"_tmp
                sed -n "${i}p" "$tmpTitles" >> "$tmpTitles"_tmp
            done
        done

        grep -v "$(grep '^https' "$tmpList"_tmp)" "$tmpList" \
        >> "$tmpList"_tmp2 && mv -f "$tmpList"_tmp2 "$tmpList"

        grep -v "$(grep '^[[:print:]]' "$tmpTitles"_tmp)" "$tmpTitles" \
        >> "$tmpTitles"_tmp2 && mv -f "$tmpTitles"_tmp2 "$tmpTitles"

        rm {"$tmpList"_tmp,"$tmpTitles"_tmp}

        printf '%s\n' " ${critical}Selected links removed...${nc}"
        unset IFS
        sleep 3

    )

    __removeWarning() (
        pgrep -x mpv >/dev/null && \
        __
        printf '%s\n' " ${critical}$tmpList is owned by mpv...retry later.${nc}"
        sleep 4
    )

    case "$1" in
        -a)
            tmpList="$AUDIO_URLS"
            tmpTitles="$AUDIO_TITLES"
            __
            read -rsn 1 -p " ${info}Remove [L]inks or the [W]hole $Type list?: ${nc}"
            [[ $(awk -F"/" '{print $NF}' "$tmp_dir"/nowPlaying 2>/dev/null) =~ Audio ]] && {
                __removeWarning
                return
            }
            
            if [[ $REPLY =~ l|L ]]; then
                __removeTmpLinks
                _ViewUrlInfo -a
            else
                rm -f {"$tmpList","$tmpTitles"} \
                {"$tmpList"_origin,"$tmpTitles"_origin}
                rm -rf "$HOME"/.parallel 2>/dev/null
                __
                echo " ${critical}$Type list removed...${nc}"
            fi
        ;;
        -q)
            tmpList="$QUEUE"
            tmpTitles="$DEFAULTITLES"
            __
            read -rsn 1 -p " ${info}Remove [L]inks or the [W]hole default list?: ${nc}"
            [[ $(awk -F"/" '{print $NF}' "$tmp_dir"/nowPlaying 2>/dev/null) =~ default ]] && {
                __removeWarning
                _ViewUrlInfo -q
            }
            if [[ $REPLY =~ l|L ]]; then
                sed -i '1d' "$tmpList"
                __removeTmpLinks
                sed -i '1s/^/#EXTM3U\n/' "$tmpList"
                _ViewUrlInfo -q
            else
                sed -i '/^[[:alpha:]]/d' "$tmpList"
                rm -f \
                {"$tmpList"_origin,"$tmp_dir"/1,"$DEFAULTITLES"{,_origin},"$DEFAULTM3UTITLES"} 2>/dev/null
                rm -rf "$HOME"/.parallel 2>/dev/null
                __
                echo " ${critical}Default list cleared...${nc}"
            fi
        ;;
        -v)
            tmpList="$VIDEO_URLS"
            tmpTitles="$VIDEO_TITLES"
            __
            read -rsn 1 -p " ${info}Remove [L]inks or the [W]hole $Type list?: ${nc}"
            [[ $(awk -F"/" '{print $NF}' "$tmp_dir"/nowPlaying 2>/dev/null) =~ Video ]] && {
                __removeWarning
                return
            }
            if [[ $REPLY =~ l|L ]]; then
                __removeTmpLinks
                _ViewUrlInfo -v
            else
                rm -f {"$tmpList","$tmpTitles"} \
                {"$tmpList"_origin,"$tmpTitles"_origin}
                __
                echo " ${critical}$Type list removed...${nc}"
            fi
        ;;
    esac

    sleep 3
    _Menu

}

_SaveRemove() {

    cd "$playlists_dir" || exit 1

    saveRemovePrompts=( "[B]ack to menu," "Save [D]efault," "Save [A]udio," \
                        "Save [V]ideo," "[R]emove a playlist." )

    if [[ -f $AUDIO_URLS ]] && [[ -f $VIDEO_URLS ]]; then

        if (( $(_GetLinesList -q) < 1 )); then
            unset saveRemovePrompts[1]
            echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
            __
        else
            echo "${info}" "${saveRemovePrompts[@]}" "${nc}"
            __
        fi
    
    elif [[ -f $AUDIO_URLS ]]; then

        if (( $(_GetLinesList -q) < 1 )); then
            unset {saveRemovePrompts[1],saveRemovePrompts[3]}
            echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
        else
            unset saveRemovePrompts[3]
            echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
            __
        fi
    
    elif [[ -f $VIDEO_URLS ]]; then

        if (( $(_GetLinesList -q) < 1 )); then
            unset {saveRemovePrompts[1],saveRemovePrompts[2]}
            echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
        else
            unset saveRemovePrompts[2]
            echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
            __
        fi
    
    elif (( $(_GetLinesList -q) < 1 )); then
        echo -e " ${critical}Nothing to save, maybe remove something?${nc}\n"
        unset {saveRemovePrompts[1],saveRemovePrompts[2],saveRemovePrompts[3]}
        echo "${info}" "${saveRemovePrompts[*]}" "${nc}"
        __
    else
        unset {saveRemovePrompts[2],saveRemovePrompts[3]}
        echo "${info}" "${saveRemovePrompts[@]}" "${nc}"
        __
    fi

    read -rsn 1 opt
    case "$opt" in
        a|A) _Save -a ;;
        b|B) _Menu ;;
        d|D)
            rm -f "$tmp_dir"/1 2>/dev/null
            _Save -q
        ;;
        r|R)
            clear; __
            PS3=""$'\n'" ${info}Choose a playlist to remove:${nc} "
            __
            select m3ufile in $(find "$playlists_dir" -not -name "default.m3u" \
                -name "*.m3u" -o -name "*.m3u_origin" \
                | sort -d | sed 's,.*/,,'); do
                [[ $(awk -F"/" '{print $NF}' "$tmp_dir"/nowPlaying 2>/dev/null) =~ temporarySelection|"$m3ufile" ]] && {
                    __
                    printf '%s\n' " ${critical}$m3ufile is owned by mpv......retry later.${nc}"
                    sleep 4
                    return
                }
                __
                _Prompt -n \
                " ${critical}Are you sure you want to remove $m3ufile?: ${nc}" && {
                    rm {"$m3ufile","$titles_dir"/"$m3ufile".titles}
                    __
                    echo " ${critical}$m3ufile removed.${nc}"
                    _mpmIpc
                    sleep 3
                    break
                }
                __
                echo " ${info}$m3ufile preserved"
                sleep 2
                break
            done
        ;;
        v|V) _Save -v ;;
    esac

    _Menu
    
}

## avoids running multiple instances
mpvmenu=$(basename $0)
pids=($(pidof -x $mpvmenu))

[[ ${#pids[@]} -gt 1 ]] && {
    notify-send -t 0 -u critical "mpm is already running..."
    exit
}

HELP="$SCRIPTDIR/mpv-playlists-manager/help"

_LaunchMpm() {
    _Prompt " ${info}Launch mpm_test? ${nc}" || {
        exit
    }
    _CheckDependencies "${@}"
}

case "$1" in
    -c) $MPMEDITOR "$MPMRC" && _LaunchMpm "$@";;
    -e) _EditPlaylist ;;
    -l) _LoadPlaylist ;;
    -p) _LoadLocal ;;
    -v) echo "mpm $VERSION" && _LaunchMpm "$@";;
    -h|--help) less "$HELP" && _LaunchMpm "$@";;
esac

_CheckDependencies "${@}"
