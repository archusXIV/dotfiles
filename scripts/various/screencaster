#!/usr/bin/env bash

# Author: Barret E 2025 <archus@protonmail.com>
# Script name: screencaster
# License: GPlv2
#
# This script records the chosen screen with both video and audio
# using ffmpeg on a Xorg session.
# It requires command line arguments like:
# screencaster -m HDMI-A-0 -a alsa_output.pci-0000_0a_00.4.analog-stereo.monitor
# If -m or -a is not provided, we will be prompt to set those required parameters.
# See the _Usage function for more options/info.
# You can also check the filters parameters and change them in the FILTERS array.

# shellcheck disable=SC2140

reset
declare -a dependencies=(
    ffmpeg
    pulseaudio
    awk
    xrandr
)

for dependency in "${dependencies[@]}"; do
    command -v "${dependency}" >/dev/null || {
        printf '%s\n' " $dependency isn't installed, exiting."
        exit 127
    }
done

grn=$'\e[32m';
red=$'\e[31m';
nc=$'\e[0m';
now=$(date +%Y-%m-%d_%H:%M:%S)

_Usage() {
    printf '%s\n' \
    " Usage: ${0##*/} [OPTION] [ARG]" \
    " -a <audio source>  See down below available sources (required!)" \
    " -b <yes/no>        Activate polybar mic/volume modules (default:no)" \
    " -d <audio delay>   If needed, to sync audio/video in milliseconds (default:0)" \
    " -D <add decibells> Number of decibells to add for the final result (default:1)" \
    " -f <audio filter>  compressor, denoiser, cutfreq (one filter only)" \
    " -l <length>        How long the screencast should last (format = HH:MM:SS)" \
    " -m <monitor name>  example: HDMI-A-0 (required!)" \
    " -o <filename>      Output file (default:$HOME/screencast_$now.mkv)" \
    " -p <preset ratio>  Set the video quality (default:veryfast)" \
    " -r <resolution>    Set the screen resolution (default:1920x1080)" \
    " -v <volume>        Set the audio source level (in percentage) using pactl (default:80)"
    echo -e "\n ${grn}Currently available audio sources:\n${nc}"
    pactl list sources short | awk '{print "  "$2}'
    exit 1
}

[[ $# -eq 0 ]] && _Usage
# Parsing arguments
while getopts "a:b:d:D:f:l:m:o:p:r:v:" opt; do
    case $opt in
        a) audio_source="${OPTARG}" ;;
        b) bar="${OPTARG}" ;;
        d) audio_delay="${OPTARG}" ;;
        D) ndB="${OPTARG}" ;;
        f) filter="${OPTARG}" ;;
        l) length="${OPTARG}" ;;
        m) monitor="${OPTARG}" ;;
        o) output_file="${OPTARG}" ;;
        p) preset="${OPTARG}";;
        r) resolution="${OPTARG}" ;;
        v) volume="${OPTARG}" ;;
        *) _Usage ;;
    esac
done

shift $((OPTIND - 1))

# Change these parameters to your likings.
# FFT-based (denoiser filter in dB)
declare -A FILTERS=(
    [compressor]="acompressor=threshold=-21dB:ratio=9:attack=200:release=1000"
    [cutfreq]="highpass=200,lowpass=5000"
    [denoiser]="afftdn=nf=-25"
)

# Default values
audio_delay=${audio_delay:-0}
bar=${bar:-no}
ndB=${ndB:-1}
output_file=${output_file:-"$HOME"/screencast_"$now".mkv}
preset=${preset:-veryfast}
resolution=${resolution:-"1920x1080"}
volume=${volume:-80}

# Validate filter if provided
if [[ -n $filter ]]; then
    if [[ -z ${FILTERS[$filter]} ]]; then
        echo " ${red}Invalid filter: $filter${nc}"
        echo " Available filters: ${grn}${!FILTERS[*]}${nc}"
        exit 1
    fi
    filter=${FILTERS[$filter]}
else
    filter=""
fi

# Giving a menu for monitor choice if not provided
[[ -z $monitor ]] && {
    printf '\n'
    PS3=""$'\n'" ${grn}Select a monitor: ${nc}"
    select m in $(xrandr --listactivemonitors | awk '$0 !~ /Monitor/{print $NF}'); do
        if [[ -n ${m+x} ]]; then
            monitor="$m"
            break
        else
            _Usage
        fi
    done
}

# ...and for audio source device too.
[[ -z $audio_source ]] && {
    printf '\n'
    PS3=""$'\n'" ${grn}Select an audio source: ${nc}"
    select a in $(pactl list sources short | awk '{print "  "$2}'); do
        if [[ -n ${a+x} ]]; then
            audio_source="$a"
            [[ $audio_source =~ output && -z $volume ]] && volume=50
            break
        else
            _Usage
        fi
    done
}

_BarActions() {
    case "$1" in
        on)
            if [[ $input == "on" ]]; then
                polybar-msg action "#mic-ipc.hook.1"
                polybar-msg action "#volume-ipc.hook.0"
            elif [[ $output == "on" ]]; then
                polybar-msg action "#mic-ipc.hook.0"
                polybar-msg action "#volume-ipc.hook.1"
            fi
        ;;
        off)
            polybar-msg action "#mic-ipc.hook.0"
            polybar-msg action "#volume-ipc.hook.1"
        ;;
    esac

} >/dev/null 2>&1

_GetInputMute() { pactl get-source-mute @DEFAULT_SOURCE@; }
_GetOutputMute() { pactl get-sink-mute @DEFAULT_SINK@; }
_SetInputMute() { pactl set-source-mute @DEFAULT_SOURCE@ "$1"; }
_SetOutputMute() { pactl set-sink-mute @DEFAULT_SINK@ "$1"; }
_SetInputVolume() { pactl set-source-volume @DEFAULT_SOURCE@ "$1"; }
_SetOutputVolume() { pactl set-sink-volume @DEFAULT_SINK@ "$1"; }
# Getting the current volume level so we can restore it when stopping the recording
read -r currentvolume < <(
    pactl get-sink-volume @DEFAULT_SINK@ \
    | awk '{if(NR!=2) {print $5}}'
)

_SetVolume() {
    case "$1" in
        on)
            if [[ $audio_source =~ input ]]; then
                _GetInputMute | grep -q 'yes' && _SetInputMute false
                _GetOutputMute | grep -q 'no' && {
                    _SetOutputVolume 0%
                    _SetOutputMute true
                }
                _SetInputVolume "$volume"%
                input=on
                [[ $bar == "yes" ]] && _BarActions on
            elif [[ $audio_source =~ output ]]; then
                _GetOutputMute | grep -q 'yes' && _SetOutputMute false
                _GetInputMute | grep -q 'no' && {
                    _SetInputVolume 0%
                    _SetInputMute true
                }
                _SetOutputVolume "$volume"%
                output=on
                [[ $bar == "yes" ]] && _BarActions on
            fi
            gsettings set org.gnome.desktop.sound event-sounds false
            ;;
        off)
            [[ $input == "on" ]] && {
                _SetInputVolume 0%
                _SetInputMute true
                _SetOutputMute false
                _SetOutputVolume "${currentvolume}"
                [[ $bar == "yes" ]] && _BarActions off
            }
            [[ $output == "on" ]] && {
                _SetOutputVolume "${currentvolume}"
                _SetOutputMute false
                [[ $bar == "yes" ]] && _BarActions off
            }
            gsettings set org.gnome.desktop.sound event-sounds true
        ;;
    esac
}

[[ -n $volume ]] && _SetVolume on


# Get monitor position (xrandr output)
monitor_position=$(
    xrandr \
    | awk -v m="$monitor" '
        $0 ~ m {split($3, a, "[+]");
        print a[2] "," a[3]}
    '
)

if [[ -z $monitor_position ]]; then
    echo " ${red}Could not determine monitor position for $monitor${nc}"
    exit 1
fi

x=${monitor_position%,*}
y=${monitor_position#*,}

_EndScreencast() {
    [[ -n $volume ]] && _SetVolume off
    reset
    notify-send 'screencast is over'
    exit 0
}

_TimeConverter() {
    IFS=":";
    if [[ $1  =~ ^[0-9]{2}:[0-9]{2}$ ]]; then
        read -r minutes seconds <<< "$1"
        total_seconds=$((minutes * 60 + seconds))
    elif [[ $1  =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
        read -r hours minutes seconds <<< "$1"
        total_seconds=$(((hours * 3600) + (minutes * 60 + seconds)))
    else
        unset IFS
        printf '\n%s\n' " ${red}Wrong duration format...${nc}"
        _Usage
    fi
    unset IFS
}

[[ -n $length ]] && {
    _TimeConverter "$length" && sleep 0.2
    # Start a background timer process and save its PID
    (
        for ((i=1;i<="$total_seconds";i++)); do
            sleep 1
            (( i == total_seconds )) && {
                kill -TERM "$(pidof ffmpeg)"
                _EndScreencast
            }
        done
    ) &
    timer_pid=$!

    # Trap SIGINT/SIGTERM to kill both ffmpeg and the timer process
    trap 'kill -TERM "$(pidof ffmpeg)" "$timer_pid"; _EndScreencast' SIGINT SIGTERM
}

ffmpeg \
    -y \
    -thread_queue_size 512 \
    -video_size "$resolution" \
    -framerate 30 \
    -f x11grab -i :0.0+"$x","$y" \
    -thread_queue_size 512 \
    -f pulse -i "$audio_source" \
    -af "${audio_delay:+adelay=${audio_delay}|${audio_delay}}${audio_delay:+,}\
        volume=${ndB}dB${filter:+,}${filter}" \
    -c:v libx264 \
    -preset "$preset" \
    -crf 23 \
    -c:a aac \
    -b:a 128k \
    -async 1 \
    -fps_mode cfr \
    "$output_file"

_EndScreencast
